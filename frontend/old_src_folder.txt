===== FOLDER STRUCTURE =====

Structure du dossier
Le numÚro de sÚrie du volume est 66D3-2B7A
C:.
|   app.ts
|   project_dump.txt
|   script.ps1
|   server.ts
|   
+---api
|       routes.ts
|       
+---config
|       database.ts
|       index.ts
|       security.ts
|       
+---controllers
|       auth.controller.ts
|       company.controller.ts
|       contract.controller.ts
|       inventory.controller.ts
|       invoice.controller.ts
|       license.controller.ts
|       proforma.controller.ts
|       user.controller.ts
|       
+---interfaces
|       user.interface.ts
|       
+---middleware
|       auth.middleware.ts
|       auth.ts
|       compression.middleware.ts
|       cors.middleware.ts
|       error.middleware.ts
|       errorHandler.ts
|       helmet.middleware.ts
|       morgan.middleware.ts
|       notFoundHandler.ts
|       rateLimit.middleware.ts
|       rateLimit.ts
|       security.ts
|       upload.middleware.ts
|       validateRequest.middleware.ts
|       validateRequest.ts
|       validation.middleware.ts
|       validation.ts
|       
+---models
|       analytics.model.ts
|       company.model.ts
|       contract.model.ts
|       inventory.model.ts
|       invoice.model.ts
|       license.model.ts
|       proforma.model.ts
|       user.model.ts
|       
+---modules
|   +---accounting
|   |   +---controllers
|   |   |       expense.controller.ts
|   |   |       invoiceAccessToken.controller.ts
|   |   |       
|   |   +---models
|   |   |       expense.model.ts
|   |   |       invoice.model.ts
|   |   |       invoiceAccessToken.model.ts
|   |   |       
|   |   +---routes
|   |   |       expense.routes.ts
|   |   |       invoice.routes.ts
|   |   |       
|   |   +---schemas
|   |   |       invoiceAccessToken.schema.ts
|   |   |       
|   |   +---services
|   |   \---validators
|   +---hr
|   |   +---controllers
|   |   |       employeeAccessToken.controller.ts
|   |   |       
|   |   +---models
|   |   |       employee.model.ts
|   |   |       employeeAccessToken.model.ts
|   |   |       
|   |   +---routes
|   |   +---schemas
|   |   |       employeeAccessToken.schema.ts
|   |   |       
|   |   +---services
|   |   \---validators
|   +---shared
|   |   +---constants
|   |   +---middleware
|   |   |       roleAuth.ts
|   |   |       
|   |   +---types
|   |   \---utils
|   \---stock
|       +---controllers
|       |       purchaseOrder.controller.ts
|       |       purchaseOrderAccessToken.controller.ts
|       |       stockAccessToken.controller.ts
|       |       stockCategory.controller.ts
|       |       stockMovement.controller.ts
|       |       supplier.controller.ts
|       |       
|       +---models
|       |       inventory.model.ts
|       |       purchaseOrder.model.ts
|       |       purchaseOrderAccessToken.model.ts
|       |       stockAccessToken.model.ts
|       |       stockCategory.model.ts
|       |       stockMovement.model.ts
|       |       supplier.model.ts
|       |       
|       +---routes
|       |       stock.routes.ts
|       |       
|       +---schemas
|       |       purchaseOrderAccessToken.schema.ts
|       |       stockAccessToken.schema.ts
|       |       stockMovement.schema.ts
|       |       
|       +---services
|       \---validators
+---routes
|       auth.routes.ts
|       company.routes.ts
|       contract.routes.ts
|       index.ts
|       inventory.routes.ts
|       invoice.routes.ts
|       license.routes.ts
|       proforma.routes.ts
|       user.routes.ts
|       
+---schemas
|       company.schema.ts
|       user.schema.ts
|       
+---scripts
|       checkUser.ts
|       createSuperAdmin.ts
|       initializeDb.ts
|       seed.ts
|       testLogin.ts
|       
+---services
|       AIService.ts
|       AnalyticsEngine.ts
|       AuthService.ts
|       CacheService.ts
|       CoreService.ts
|       EventBus.ts
|       MonitoringService.ts
|       NotificationService.ts
|       OptimizationEngine.ts
|       pdf.service.ts
|       ReportingEngine.ts
|       ReportingService.ts
|       WebSocketService.ts
|       
+---types
|       authRequest.ts
|       error.ts
|       express.d.ts
|       
+---utils
|       ApiError.ts
|       appError.ts
|       auth.ts
|       cache.ts
|       catchAsync.ts
|       email.ts
|       license.ts
|       logger.ts
|       passwordValidator.ts
|       totp.ts
|       upload.ts
|       validateEnv.ts
|       
+---validation
|       auth.validation.ts
|       
\---validators
        auth.validator.ts
        company.validator.ts
        invoice.validator.ts
        


===== FILE CONTENTS =====

===== C:\Users\Badr Admin\Desktop\src\app.ts =====
import express from 'express';
import cors from 'cors';
import morgan from 'morgan';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import mongoSanitize from 'express-mongo-sanitize';
import xss from 'xss-clean';
import hpp from 'hpp';
import compression from 'compression';
import { errorHandler } from './middleware/error.middleware';
import { typedLogger } from './utils/logger';
import userRoutes from './routes/user.routes';
import { config } from './config';
import { authMiddleware } from './middleware/auth.middleware';
import routes from './routes';

const app = express();

// Set security HTTP headers
app.use(helmet());

// Development logging
if (process.env.NODE_ENV === 'development') {
  app.use(morgan('dev'));
}

// Limit requests from same API
const limiter = rateLimit({
  max: 100,
  windowMs: 60 * 60 * 1000,
  message: 'Too many requests from this IP, please try again in an hour!'
});
app.use('/api', limiter);

// Body parser, reading data from body into req.body
app.use(express.json({ limit: '10kb' }));
app.use(express.urlencoded({ extended: true, limit: '10kb' }));

// Data sanitization against NoSQL query injection
app.use(mongoSanitize());

// Data sanitization against XSS
app.use(xss());

// Prevent parameter pollution
app.use(hpp());

// Enable CORS
app.use(cors());

// Compress all responses
app.use(compression());

// Routes
app.use('/api/v1/users', userRoutes);
app.use('/api', routes);

// Error handling
app.use(errorHandler);

// Handle unhandled routes
app.all('*', (req, res, next) => {
  res.status(404).json({
    status: 'fail',
    message: `Can't find ${req.originalUrl} on this server!`
  });
});

// Handle unhandled rejections
process.on('unhandledRejection', (err: Error) => {
  typedLogger.error('UNHANDLED REJECTION! ðŸ’¥ Shutting down...', err);
  process.exit(1);
});

// Handle uncaught exceptions
process.on('uncaughtException', (err: Error) => {
  typedLogger.error('UNCAUGHT EXCEPTION! ðŸ’¥ Shutting down...', err);
  process.exit(1);
});

export default app; 

===== C:\Users\Badr Admin\Desktop\src\server.ts =====
import express, { Express, RequestHandler } from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import { config } from './config';
import { errorHandler } from './middleware/error.middleware';
import routes from './routes';
import { connectDatabase } from './config/database';
import http from 'http';
import logger from './utils/logger';
import mongoose from 'mongoose';
import { typedLogger } from './utils/logger';

// Create Express app
const app: Express = express();

// Create HTTP server
const server = http.createServer(app);

// CORS configuration - must be before other middleware
app.use(cors({
  origin: 'http://localhost:3000',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'Cookie'],
  exposedHeaders: ['set-cookie']
}));

// Middleware
app.use(express.json());
app.use(cookieParser as unknown as () => RequestHandler);

// Add request logging middleware
app.use((req, _res, next) => {
  logger.info(`${req.method} ${req.url}`, {
    headers: req.headers,
    body: req.body,
    query: req.query,
    params: req.params
  });
  next();
});

// Routes
app.use('/api', routes);

// Error handling
app.use(errorHandler);

// Connect to MongoDB and start server
const PORT = process.env.PORT || 3000;
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/stock_hr';

mongoose
  .connect(MONGODB_URI)
  .then(() => {
    typedLogger.info('Connected to MongoDB');
    app.listen(PORT, () => {
      typedLogger.info(`Server running on port ${PORT}`);
    });
  })
  .catch((error) => {
    typedLogger.error('Error connecting to MongoDB:', error);
    process.exit(1);
  });

// Handle server shutdown
process.on('SIGTERM', () => {
  logger.info('SIGTERM signal received. Closing HTTP server...');
  server.close(() => {
    logger.info('HTTP server closed');
    process.exit(0);
  });
});

export default app;

===== C:\Users\Badr Admin\Desktop\src\api\routes.ts =====
import { Router } from 'express';
import { auth } from '../middleware/auth';
import * as controllers from '../controllers';

const router = Router();

// Auth routes
router.post('/auth/login', controllers.auth.login);
router.post('/auth/register', controllers.auth.register);
router.post('/auth/refresh-token', controllers.auth.refreshToken);
router.post('/auth/logout', auth, controllers.auth.logout);

// User routes
router.get('/users', auth, controllers.users.getAll);
router.get('/users/:id', auth, controllers.users.getById);
router.put('/users/:id', auth, controllers.users.update);
router.delete('/users/:id', auth, controllers.users.delete);

// Inventory routes
router.get('/inventory', auth, controllers.inventory.getAll);
router.post('/inventory', auth, controllers.inventory.create);
router.put('/inventory/:id', auth, controllers.inventory.update);
router.delete('/inventory/:id', auth, controllers.inventory.delete);

// Analytics routes
router.get('/analytics/dashboard', auth, controllers.analytics.getDashboard);
router.get('/analytics/reports', auth, controllers.analytics.getReports);
router.post('/analytics/generate-report', auth, controllers.analytics.generateReport);

export default router;


===== C:\Users\Badr Admin\Desktop\src\config\database.ts =====
import mongoose from 'mongoose';
import { config } from './index';

let retryCount = 0;
const MAX_RETRIES = 5;

export const connectDatabase = async () => {
  try {
    await mongoose.connect(config.database.uri, {
      autoIndex: true,
      serverSelectionTimeoutMS: 5000,
      connectTimeoutMS: 10000,
      socketTimeoutMS: 45000,
    });
    console.log('MongoDB connected successfully');
    retryCount = 0; // Reset retry count on successful connection
  } catch (error) {
    console.error('MongoDB connection error:', error);
    if (retryCount < MAX_RETRIES) {
      retryCount++;
      console.log(`Retrying connection... Attempt ${retryCount} of ${MAX_RETRIES}`);
      setTimeout(connectDatabase, 5000); // Wait 5 seconds before retrying
    } else {
      console.error('Max retry attempts reached. Exiting process.');
      process.exit(1);
    }
  }
};

mongoose.connection.on('error', (error) => {
  console.error('MongoDB error:', error);
});

mongoose.connection.on('disconnected', () => {
  console.warn('MongoDB disconnected. Attempting to reconnect...');
  connectDatabase();
});

===== C:\Users\Badr Admin\Desktop\src\config\index.ts =====
import dotenv from 'dotenv';
import path from 'path';

dotenv.config();

export const config = {
  env: process.env.NODE_ENV || 'development',
  port: parseInt(process.env.PORT || '5000', 10),
  database: {
    uri: process.env.MONGODB_URI || 'mongodb://localhost:27017/stockhr',
  },
  jwt: {
    secret: process.env.JWT_SECRET || 'your-super-secret-jwt-key',
    expiresIn: process.env.JWT_EXPIRES_IN || '24h',
    refreshExpiresIn: '7d',
  },
  email: {
    host: process.env.SMTP_HOST,
    port: parseInt(process.env.SMTP_PORT || '587', 10),
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
  storage: {
    uploads: path.join(__dirname, '../../uploads'),
    maxFileSize: parseInt(process.env.MAX_FILE_SIZE || '5242880', 10), // 5MB
  },
  redis: {
    url: process.env.REDIS_URL || 'redis://localhost:6379',
  },
  security: {
    bcryptRounds: 10,
    rateLimitWindowMs: 15 * 60 * 1000, // 15 minutes
    rateLimitMax: 100, // limit each IP to 100 requests per windowMs
  }
};

export default config;


===== C:\Users\Badr Admin\Desktop\src\config\security.ts =====
import { Express } from 'express';
import csrf from 'csurf';
import rateLimit from 'express-rate-limit';
import session from 'express-session';

export const setupSecurity = (app: Express): void => {
  // Session configuration
  app.use(session({
    secret: process.env.SESSION_SECRET || 'your-secret-key',
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: process.env.NODE_ENV === 'production',
      httpOnly: true,
      maxAge: 24 * 60 * 60 * 1000 // 24 hours
    }
  }));

  // CSRF protection
  app.use(csrf({ cookie: true }));

  // Rate limiting
  const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100 // limit each IP to 100 requests per windowMs
  });
  app.use(limiter);

  // Additional security headers
  app.use((req, res, next) => {
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    next();
  });
}; 

===== C:\Users\Badr Admin\Desktop\src\controllers\auth.controller.ts =====
import { Request, Response, NextFunction, CookieOptions } from 'express';
import jwt, { SignOptions } from 'jsonwebtoken';
import crypto from 'crypto';
import { User } from '../models/user.model';
import { AppError } from '../utils/appError';
import { sendEmail } from '../utils/email';
import { catchAsync } from '../utils/catchAsync';
import { validatePassword } from '../utils/passwordValidator';
import { config } from '../config';
import { createSendToken } from '../utils/auth';
import { IUser } from '../interfaces/user.interface';

const JWT_EXPIRES_IN = '24h';
const COOKIE_EXPIRES_IN = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

const signToken = (id: string) => {
  const options: SignOptions = {
    expiresIn: JWT_EXPIRES_IN
  };
  return jwt.sign({ id }, config.jwt.secret, options);
};

export const register = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { username } = req.body;
  
  // Check if user exists
  const existingUser = await User.findOne({ username });
  if (existingUser) {
    return next(AppError.conflict('Username already in use'));
  }

  // Validate password
  const passwordValidation = validatePassword(req.body.password);
  if (!passwordValidation.isValid) {
    return next(AppError.validationError(passwordValidation.error!));
  }

  // Create new user
  const newUser = await User.create({
    username: req.body.username,
    password: req.body.password,
    role: req.body.role || 'user',
    isActive: true
  });

  createSendToken(newUser, 201, res);
});

export const authController = {
  login: catchAsync(async (req: Request, res: Response, next: NextFunction) => {
    const { username, password } = req.body;

    // 1) Check if username and password exist
    if (!username || !password) {
      return next(new AppError('Please provide username and password', 400));
    }

    // 2) Check if user exists && password is correct
    const user = await User.findOne({ username }).select('+password');
    
    if (!user || !(await user.comparePassword(password))) {
      return next(new AppError('Incorrect username or password', 401));
    }

    // 3) If everything ok, send token to client
    createSendToken(user, 200, res);
  }),

  logout: (req: Request, res: Response) => {
    res.status(200).json({ status: 'success' });
  },

  forgotPassword: catchAsync(async (req: Request, res: Response, next: NextFunction) => {
    // 1) Get user based on POSTed username
    const user = await User.findOne({ username: req.body.username });
    if (!user) {
      return next(new AppError('There is no user with that username', 404));
    }

    // 2) Generate the random reset token
    const resetToken = user.createPasswordResetToken();
    await user.save({ validateBeforeSave: false });

    // 3) Send it to user's email
    try {
      // TODO: Implement email sending
      res.status(200).json({
        status: 'success',
        message: 'Token sent to email!'
      });
    } catch (err) {
      user.passwordResetToken = undefined;
      user.passwordResetExpires = undefined;
      await user.save({ validateBeforeSave: false });

      return next(
        new AppError('There was an error sending the email. Try again later!', 500)
      );
    }
  }),

  resetPassword: catchAsync(async (req: Request, res: Response, next: NextFunction) => {
    // 1) Get user based on the token
    const hashedToken = crypto
      .createHash('sha256')
      .update(req.params.token)
      .digest('hex');

    const user = await User.findOne({
      passwordResetToken: hashedToken,
      passwordResetExpires: { $gt: Date.now() }
    });

    // 2) If token has not expired, and there is user, set the new password
    if (!user) {
      return next(new AppError('Token is invalid or has expired', 400));
    }
    user.password = req.body.password;
    user.passwordResetToken = undefined;
    user.passwordResetExpires = undefined;
    await user.save();

    // 3) Update changedPasswordAt property for the user
    // 4) Log the user in, send JWT
    createSendToken(user, 200, res);
  }),

  changePassword: catchAsync(async (req: Request, res: Response, next: NextFunction) => {
    // 1) Get user from collection
    const user = await User.findById(req.user?._id).select('+password');
    if (!user) {
      return next(new AppError('User not found', 404));
    }

    // 2) Check if POSTed current password is correct
    if (!(await user.comparePassword(req.body.currentPassword))) {
      return next(new AppError('Your current password is wrong', 401));
    }

    // 3) If so, update password
    user.password = req.body.newPassword;
    await user.save();

    // 4) Log user in, send JWT
    createSendToken(user, 200, res);
  }),

  updateProfile: catchAsync(async (req: Request, res: Response, next: NextFunction) => {
    // 1) Create error if user POSTs password data
    if (req.body.password || req.body.passwordConfirm) {
      return next(
        new AppError(
          'This route is not for password updates. Please use /updateMyPassword',
          400
        )
      );
    }

    // 2) Filtered out unwanted fields names that are not allowed to be updated
    const filteredBody = filterObj(req.body, 'firstName', 'lastName', 'settings');

    // 3) Update user document
    const updatedUser = await User.findByIdAndUpdate(req.user?._id, filteredBody, {
      new: true,
      runValidators: true
    });

    res.status(200).json({
      status: 'success',
      data: {
        user: updatedUser
      }
    });
  })
};

// Helper function to filter out unwanted fields
const filterObj = (obj: any, ...allowedFields: string[]) => {
  const newObj: any = {};
  Object.keys(obj).forEach(el => {
    if (allowedFields.includes(el)) newObj[el] = obj[el];
  });
  return newObj;
};

===== C:\Users\Badr Admin\Desktop\src\controllers\company.controller.ts =====
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../utils/appError';
import { Company } from '../models/company.model';
import { catchAsync } from '../utils/catchAsync';

export const companyController = {
  async getAll(req: Request, res: Response, next: NextFunction) {
    try {
      const companies = await Company.find();
      res.json(companies);
    } catch (error) {
      next(error);
    }
  },

  async getById(req: Request, res: Response, next: NextFunction) {
    try {
      const company = await Company.findById(req.params.id);
      if (!company) {
        throw AppError.notFound('Company not found');
      }
      res.json(company);
    } catch (error) {
      next(error);
    }
  },

  async create(req: Request, res: Response, next: NextFunction) {
    try {
      const company = await Company.create(req.body);
      res.status(201).json(company);
    } catch (error) {
      next(error);
    }
  },

  async update(req: Request, res: Response, next: NextFunction) {
    try {
      const company = await Company.findByIdAndUpdate(
        req.params.id,
        req.body,
        { new: true, runValidators: true }
      );
      if (!company) {
        throw AppError.notFound('Company not found');
      }
      res.json(company);
    } catch (error) {
      next(error);
    }
  },

  async delete(req: Request, res: Response, next: NextFunction) {
    try {
      const company = await Company.findByIdAndDelete(req.params.id);
      if (!company) {
        throw AppError.notFound('Company not found');
      }
      res.status(204).send();
    } catch (error) {
      next(error);
    }
  },

  // Get company details
  getCompanyDetails: catchAsync(async (_req: Request, res: Response) => {
    const company = await Company.findOne();
    if (!company) {
      throw new AppError(404, 'Company details not found');
    }
    res.json(company);
  }),

  // Update company details
  updateCompanyDetails: catchAsync(async (req: Request, res: Response) => {
    const company = await Company.findOne();
    if (!company) {
      throw new AppError(404, 'Company details not found');
    }

    const updatedCompany = await Company.findByIdAndUpdate(
      company._id,
      { $set: req.body },
      { new: true, runValidators: true }
    );

    res.json(updatedCompany);
  }),

  // Upload company logo
  uploadLogo: catchAsync(async (req: Request, res: Response) => {
    if (!req.file) {
      throw new AppError(400, 'No file uploaded');
    }

    const company = await Company.findOne();
    if (!company) {
      throw new AppError(404, 'Company details not found');
    }

    // Update logo path
    const logoPath = `/uploads/logos/${req.file.filename}`;
    const updatedCompany = await Company.findByIdAndUpdate(
      company._id,
      { $set: { logo: logoPath } },
      { new: true, runValidators: true }
    );

    res.json(updatedCompany);
  }),
}; 

===== C:\Users\Badr Admin\Desktop\src\controllers\contract.controller.ts =====
import { Request, Response, NextFunction } from 'express';
import { jsPDF } from 'jspdf'; // Add this library for PDF generation
import Contract from '../models/contract.model';
import { AppError } from '../utils/appError';
import { AuthRequest } from '../types/authRequest';

export const getAllContracts = async (
  _req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const contracts = await Contract.find().sort({ createdAt: -1 });
    
    res.status(200).json({
      status: 'success',
      results: contracts.length,
      data: {
        contracts
      }
    });
  } catch (error) {
    next(error);
  }
};

export const getContractById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const contract = await Contract.findById(req.params.id);
    
    if (!contract) {
      return next(new AppError(404, 'Contract not found'));
    }

    res.status(200).json({
      status: 'success',
      data: {
        contract
      }
    });
  } catch (error) {
    next(error);
  }
};

export const createContract = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    if (!req.user) {
      return next(new AppError(401, 'Authentication required'));
    }

    // Generate contract number
    const count = await Contract.countDocuments();
    const contractNumber = `CNT-${String(count + 1).padStart(6, '0')}`;

    const contract = await Contract.create({
      ...req.body,
      contractNumber,
      createdBy: req.user._id
    });

    res.status(201).json({
      status: 'success',
      data: {
        contract
      }
    });
  } catch (error) {
    next(error);
  }
};

export const updateContract = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    if (!req.user) {
      return next(new AppError(401, 'Authentication required'));
    }

    const contract = await Contract.findByIdAndUpdate(
      req.params.id,
      req.body,
      {
        new: true,
        runValidators: true
      }
    );

    if (!contract) {
      return next(new AppError(404, 'Contract not found'));
    }

    res.status(200).json({
      status: 'success',
      data: {
        contract
      }
    });
  } catch (error) {
    next(error);
  }
};

export const deleteContract = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    if (!req.user) {
      return next(new AppError(401, 'Authentication required'));
    }

    const contract = await Contract.findByIdAndDelete(req.params.id);

    if (!contract) {
      return next(new AppError(404, 'Contract not found'));
    }

    res.status(204).json({
      status: 'success',
      data: null
    });
  } catch (error) {
    next(error);
  }
};

export const generateContract = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    if (!req.user) {
      return next(new AppError(401, 'Authentication required'));
    }

    const { title, description, startDate, endDate, party } = req.body;

    // Generate contract content
    const contractContent = `
      Contract Title: ${title}
      Description: ${description}
      Start Date: ${startDate}
      End Date: ${endDate}
      Party: ${party.name}, ${party.type}, ${party.contact}, ${party.address}
    `;

    // Generate PDF
    const doc = new jsPDF();
    doc.text(contractContent, 10, 10);
    const pdfBuffer = doc.output('arraybuffer');

    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', 'attachment; filename=contract.pdf');
    res.status(200).send(Buffer.from(pdfBuffer));
  } catch (error) {
    next(error);
  }
};

// Additional function to generate contract document
export const generateContractDocument = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const contract = await Contract.findById(req.params.id);
    
    if (!contract) {
      return next(new AppError(404, 'Contract not found'));
    }

    // TODO: Implement contract document generation logic
    // This could involve using a library like PDFKit to generate a PDF
    // For now, we'll return a simple success message
    
    res.status(200).json({
      status: 'success',
      message: 'Contract document generated successfully',
      data: {
        contract
      }
    });
  } catch (error) {
    next(error);
  }
};

===== C:\Users\Badr Admin\Desktop\src\controllers\inventory.controller.ts =====
import { Request, Response, NextFunction } from 'express';
import { InventoryItem } from '../models/inventory.model';
import { WebSocketService } from '../services/WebSocketService';

export class InventoryController {
  private wsService: WebSocketService;

  constructor(server: any) {
    this.wsService = WebSocketService.getInstance(server);
  }

  public getAll = async (_req: Request, res: Response, next: NextFunction) => {
    try {
      const items = await InventoryItem.find();
      res.status(200).json({ status: 'success', data: { items } });
    } catch (error) {
      next(error);
    }
  };

  public create = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const item = await InventoryItem.create(req.body);
      this.wsService.broadcast('inventory:created', item);
      res.status(201).json({ status: 'success', data: { item } });
    } catch (error) {
      next(error);
    }
  };

  public update = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const item = await InventoryItem.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true });
      if (!item) {
        return res.status(404).json({ status: 'fail', message: 'Item not found' });
      }
      this.wsService.broadcast('inventory:updated', item);
      return res.status(200).json({ status: 'success', data: { item } });
    } catch (error) {
      next(error);
      return; // Ensure all code paths return
    }
  };

  public delete = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const item = await InventoryItem.findByIdAndDelete(req.params.id);
      if (!item) {
        return res.status(404).json({ status: 'fail', message: 'Item not found' });
      }
      this.wsService.broadcast('inventory:deleted', { id: req.params.id });
      return res.status(204).json({ status: 'success', data: null });
    } catch (error) {
      next(error);
      return; // Ensure all code paths return
    }
  };
}

export const getAllItems = async (_req: Request, res: Response, next: NextFunction) => {
  try {
    const items = await InventoryItem.find();
    res.status(200).json({ status: 'success', data: { items } });
  } catch (error) {
    next(error);
  }
};

export const getItemById = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const item = await InventoryItem.findById(req.params.id);
    if (!item) {
      return res.status(404).json({ status: 'fail', message: 'Item not found' });
    }
    return res.status(200).json({ status: 'success', data: { item } });
  } catch (error) {
    next(error);
    return;
  }
};

export const updateItem = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const item = await InventoryItem.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true });
    if (!item) {
      return res.status(404).json({ status: 'fail', message: 'Item not found' });
    }
    return res.status(200).json({ status: 'success', data: { item } });
  } catch (error) {
    next(error);
    return;
  }
};

export const deleteItem = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const item = await InventoryItem.findByIdAndDelete(req.params.id);
    if (!item) {
      return res.status(404).json({ status: 'fail', message: 'Item not found' });
    }
    return res.status(204).json({ status: 'success', data: null });
  } catch (error) {
    next(error);
    return;
  }
};

export const createItem = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const item = await InventoryItem.create(req.body);
    res.status(201).json({ status: 'success', data: { item } });
  } catch (error) {
    next(error);
  }
};

// Provide the required server argument when creating an instance
export default (server: any) => new InventoryController(server);

===== C:\Users\Badr Admin\Desktop\src\controllers\invoice.controller.ts =====
import { Request, Response, NextFunction } from 'express';
import Invoice from '../models/invoice.model';
import { AppError } from '../utils/appError';
import { AuthRequest } from '../types/authRequest';
import { Company } from '../models/company.model';
import { PDFService } from '../services/pdf.service';

export const getAllInvoices = async (
  _req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const invoices = await Invoice.find().sort({ createdAt: -1 });
    
    res.status(200).json({
      status: 'success',
      results: invoices.length,
      data: {
        invoices
      }
    });
  } catch (error) {
    next(error);
  }
};

export const getInvoiceById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const invoice = await Invoice.findById(req.params.id);
    
    if (!invoice) {
      return next(new AppError(404, 'Invoice not found'));
    }

    res.status(200).json({
      status: 'success',
      data: {
        invoice
      }
    });
  } catch (error) {
    next(error);
  }
};

export const createInvoice = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    if (!req.user) {
      return next(new AppError(401, 'Authentication required'));
    }

    // Generate invoice number
    const count = await Invoice.countDocuments();
    const invoiceNumber = `INV-${String(count + 1).padStart(6, '0')}`;

    const invoice = await Invoice.create({
      ...req.body,
      invoiceNumber,
      createdBy: req.user.id
    });

    res.status(201).json({
      status: 'success',
      data: {
        invoice
      }
    });
  } catch (error) {
    next(error);
  }
};

export const updateInvoice = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    if (!req.user) {
      return next(new AppError(401, 'Authentication required'));
    }

    const invoice = await Invoice.findByIdAndUpdate(
      req.params.id,
      req.body,
      {
        new: true,
        runValidators: true
      }
    );

    if (!invoice) {
      return next(new AppError(404, 'Invoice not found'));
    }

    res.status(200).json({
      status: 'success',
      data: {
        invoice
      }
    });
  } catch (error) {
    next(error);
  }
};

export const deleteInvoice = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    if (!req.user) {
      return next(new AppError(401, 'Authentication required'));
    }

    const invoice = await Invoice.findByIdAndDelete(req.params.id);

    if (!invoice) {
      return next(new AppError(404, 'Invoice not found'));
    }

    res.status(204).json({
      status: 'success',
      data: null
    });
  } catch (error) {
    next(error);
  }
};

export class InvoiceController {
  // Create a new invoice (proforma or final)
  public static async createInvoice(req: AuthRequest, res: Response): Promise<void> {
    try {
      const { type, client, items, paymentTerms, dueDate } = req.body;

      if (!req.user) {
        res.status(401).json({ message: 'Authentication required' });
        return;
      }

      // Get company details
      const company = await Company.findOne();
      if (!company) {
        res.status(400).json({ message: 'Company details not found. Please set up company information first.' });
        return;
      }

      // Generate invoice number
      const lastInvoice = await Invoice.findOne().sort({ invoiceNumber: -1 });
      const lastNumber = lastInvoice ? parseInt(lastInvoice.invoiceNumber.split('-')[1]) : 0;
      const invoiceNumber = `INV-${String(lastNumber + 1).padStart(6, '0')}`;

      // Create invoice
      const invoice = new Invoice({
        invoiceNumber,
        type,
        company: {
          name: company.name,
          address: company.address,
          nif: company.nif,
        },
        client,
        items,
        paymentTerms,
        dueDate,
        createdBy: req.user.id,
      });

      await invoice.save();
      res.status(201).json(invoice);
    } catch (error) {
      res.status(500).json({ message: 'Error creating invoice', error });
    }
  }

  // Get all invoices
  public static async getInvoices(_req: AuthRequest, res: Response): Promise<void> {
    try {
      const invoices = await Invoice.find()
        .sort({ createdAt: -1 })
        .populate('createdBy', 'firstName lastName');

      res.json(invoices);
    } catch (error) {
      res.status(500).json({ message: 'Error fetching invoices', error });
    }
  }

  // Get invoice by ID
  public static async getInvoiceById(req: AuthRequest, res: Response): Promise<void> {
    try {
      const invoice = await Invoice.findById(req.params.id)
        .populate('createdBy', 'firstName lastName');

      if (!invoice) {
        res.status(404).json({ message: 'Invoice not found' });
        return;
      }

      res.json(invoice);
    } catch (error) {
      res.status(500).json({ message: 'Error fetching invoice', error });
    }
  }

  // Update invoice
  public static async updateInvoice(req: AuthRequest, res: Response): Promise<void> {
    try {
      const invoice = await Invoice.findById(req.params.id);

      if (!invoice) {
        res.status(404).json({ message: 'Invoice not found' });
        return;
      }

      // Don't allow updates if invoice is validated
      if (invoice.status === 'validated') {
        res.status(400).json({ message: 'Cannot update a validated invoice' });
        return;
      }

      const updatedInvoice = await Invoice.findByIdAndUpdate(
        req.params.id,
        req.body,
        { new: true }
      );

      res.json(updatedInvoice);
    } catch (error) {
      res.status(500).json({ message: 'Error updating invoice', error });
    }
  }

  // Delete invoice
  public static async deleteInvoice(req: AuthRequest, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({ message: 'Authentication required' });
        return;
      }

      const invoice = await Invoice.findById(req.params.id);

      if (!invoice) {
        res.status(404).json({ message: 'Invoice not found' });
        return;
      }

      // Don't allow deletion if invoice is validated
      if (invoice.status === 'validated') {
        res.status(400).json({ message: 'Cannot delete a validated invoice' });
        return;
      }

      await Invoice.findByIdAndDelete(req.params.id);
      res.status(204).json();
    } catch (error) {
      res.status(500).json({ message: 'Error deleting invoice', error });
    }
  }

  // Validate invoice (only for final invoices)
  public static async validateInvoice(req: AuthRequest, res: Response): Promise<void> {
    try {
      const invoice = await Invoice.findById(req.params.id);

      if (!invoice) {
        res.status(404).json({ message: 'Invoice not found' });
        return;
      }

      if (invoice.type !== 'final') {
        res.status(400).json({ message: 'Only final invoices can be validated' });
        return;
      }

      if (invoice.status === 'validated') {
        res.status(400).json({ message: 'Invoice is already validated' });
        return;
      }

      invoice.status = 'validated';
      await invoice.save();

      res.json(invoice);
    } catch (error) {
      res.status(500).json({ message: 'Error validating invoice', error });
    }
  }

  // Convert proforma to final invoice
  public static async convertProformaToInvoice(req: AuthRequest, res: Response): Promise<void> {
    try {
      const proforma = await Invoice.findById(req.params.id);

      if (!proforma) {
        res.status(404).json({ message: 'Proforma invoice not found' });
        return;
      }

      if (proforma.type !== 'proforma') {
        res.status(400).json({ message: 'Only proforma invoices can be converted' });
        return;
      }

      // Create new final invoice
      const proformaObj = proforma.toObject();
      const finalInvoice = new Invoice({
        invoiceNumber: proformaObj.invoiceNumber,
        type: 'final',
        company: proformaObj.company,
        client: proformaObj.client,
        items: proformaObj.items,
        paymentTerms: proformaObj.paymentTerms,
        dueDate: proformaObj.dueDate,
        proformaId: proforma._id,
        status: 'draft'
      });

      await finalInvoice.save();
      res.status(201).json(finalInvoice);
    } catch (error) {
      res.status(500).json({ message: 'Error converting proforma to invoice', error });
    }
  }

  public async generatePDF(req: AuthRequest, res: Response, next: NextFunction) {
    try {
      const invoice = await Invoice.findById(req.params.id);
      if (!invoice) {
        throw new AppError(404, 'Invoice not found');
      }

      const company = await Company.findById(invoice.company);
      if (!company) {
        throw new AppError(404, 'Company not found');
      }

      const pdfPath = await PDFService.generateInvoicePDF(invoice, company);
      res.download(pdfPath);
    } catch (error) {
      next(error);
    }
  }
} 

===== C:\Users\Badr Admin\Desktop\src\controllers\license.controller.ts =====
import { Request, Response, NextFunction } from 'express';
import License from '../models/license.model'; // Assuming a License model exists

export const getAllLicenses = async (
  _req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const licenses = await License.find();
    return res.status(200).json({
      status: 'success',
      data: {
        licenses
      }
    });
  } catch (error) {
    return next(error);
  }
};

export const getLicenseById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const license = await License.findById(req.params.id);
    if (!license) {
      return res.status(404).json({
        status: 'fail',
        message: 'License not found'
      });
    }
    return res.status(200).json({
      status: 'success',
      data: {
        license
      }
    });
  } catch (error) {
    return next(error);
  }
};

export const createLicense = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const license = await License.create(req.body);
    return res.status(201).json({
      status: 'success',
      data: { license },
    });
  } catch (error) {
    return next(error);
  }
};

export const updateLicense = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const license = await License.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true,
    });
    if (!license) {
      return res.status(404).json({ status: 'fail', message: 'License not found' });
    }
    return res.status(200).json({
      status: 'success',
      data: { license },
    });
  } catch (error) {
    return next(error);
  }
};

export const deleteLicense = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const license = await License.findByIdAndDelete(req.params.id);
    if (!license) {
      return res.status(404).json({ status: 'fail', message: 'License not found' });
    }
    return res.status(204).json({ status: 'success', data: null });
  } catch (error) {
    return next(error);
  }
};

===== C:\Users\Badr Admin\Desktop\src\controllers\proforma.controller.ts =====
import { Request, Response, NextFunction } from 'express';
import { jsPDF } from 'jspdf';
import Proforma from '../models/proforma.model';
import { AppError } from '../utils/appError';
import { AuthRequest } from '../types/authRequest';

export const getAllProformas = async (
  _req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const proformas = await Proforma.find().sort({ createdAt: -1 });
    
    res.status(200).json({
      status: 'success',
      results: proformas.length,
      data: {
        proformas
      }
    });
  } catch (error) {
    next(error);
  }
};

export const getProformaById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const proforma = await Proforma.findById(req.params.id);
    
    if (!proforma) {
      return next(new AppError('Proforma invoice not found', 404));
    }

    res.status(200).json({
      status: 'success',
      data: {
        proforma
      }
    });
  } catch (error) {
    next(error);
  }
};

export const createProforma = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    if (!req.user) {
      return next(new AppError('Authentication required', 401));
    }

    // Generate proforma number (PF-YYYY-XXX)
    const year = new Date().getFullYear();
    const count = await Proforma.countDocuments({
      invoiceNumber: new RegExp(`^PF-${year}-`)
    });
    const invoiceNumber = `PF-${year}-${String(count + 1).padStart(3, '0')}`;

    const proforma = await Proforma.create({
      ...req.body,
      invoiceNumber,
      createdBy: req.user._id
    });

    res.status(201).json({
      status: 'success',
      data: {
        proforma
      }
    });
  } catch (error) {
    next(error);
  }
};

export const updateProforma = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    if (!req.user) {
      return next(new AppError('Authentication required', 401));
    }

    const proforma = await Proforma.findById(req.params.id);

    if (!proforma) {
      return next(new AppError('Proforma invoice not found', 404));
    }

    if (proforma.status === 'finalized') {
      return next(new AppError('Cannot edit a finalized proforma invoice', 400));
    }

    const updatedProforma = await Proforma.findByIdAndUpdate(
      req.params.id,
      req.body,
      {
        new: true,
        runValidators: true
      }
    );

    res.status(200).json({
      status: 'success',
      data: {
        proforma: updatedProforma
      }
    });
  } catch (error) {
    next(error);
  }
};

export const deleteProforma = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    if (!req.user) {
      return next(new AppError('Authentication required', 401));
    }

    const proforma = await Proforma.findById(req.params.id);

    if (!proforma) {
      return next(new AppError('Proforma invoice not found', 404));
    }

    if (proforma.status === 'finalized') {
      return next(new AppError('Cannot delete a finalized proforma invoice', 400));
    }

    await proforma.deleteOne();

    res.status(204).json({
      status: 'success',
      data: null
    });
  } catch (error) {
    next(error);
  }
};

export const finalizeProforma = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    if (!req.user) {
      return next(new AppError('Authentication required', 401));
    }

    const proforma = await Proforma.findById(req.params.id);

    if (!proforma) {
      return next(new AppError('Proforma invoice not found', 404));
    }

    if (proforma.status === 'finalized') {
      return next(new AppError('Proforma invoice is already finalized', 400));
    }

    proforma.status = 'finalized';
    await proforma.save();

    res.status(200).json({
      status: 'success',
      data: {
        proforma
      }
    });
  } catch (error) {
    next(error);
  }
};

export const generatePDF = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const proforma = await Proforma.findById(req.params.id);
    
    if (!proforma) {
      return next(new AppError('Proforma invoice not found', 404));
    }

    // Create PDF
    const doc = new jsPDF();
    
    // Add header
    doc.setFontSize(20);
    doc.text('PROFORMA INVOICE', 105, 20, { align: 'center' });
    
    // Add invoice details
    doc.setFontSize(12);
    doc.text(`Invoice Number: ${proforma.invoiceNumber}`, 20, 40);
    doc.text(`Date: ${proforma.date.toLocaleDateString()}`, 20, 50);
    
    // Add seller details
    doc.text('Seller Details:', 20, 70);
    doc.text(`Name: ${proforma.seller.name}`, 20, 80);
    doc.text(`Address: ${proforma.seller.address}`, 20, 90);
    doc.text(`NIF: ${proforma.seller.nif}`, 20, 100);
    doc.text(`RC: ${proforma.seller.rc}`, 20, 110);
    doc.text(`AI: ${proforma.seller.ai}`, 20, 120);
    doc.text(`IBAN: ${proforma.seller.iban}`, 20, 130);
    doc.text(`Bank: ${proforma.seller.bank}`, 20, 140);
    
    // Add buyer details
    doc.text('Buyer Details:', 20, 160);
    doc.text(`Name: ${proforma.buyer.name}`, 20, 170);
    doc.text(`Address: ${proforma.buyer.address}`, 20, 180);
    if (proforma.buyer.companyId) {
      doc.text(`Company ID: ${proforma.buyer.companyId}`, 20, 190);
    }
    
    // Add items table
    doc.text('Items:', 20, 210);
    let y = 220;
    proforma.items.forEach((item, index) => {
      doc.text(`${index + 1}. ${item.description}`, 20, y);
      doc.text(`Qty: ${item.quantity}`, 100, y);
      doc.text(`Price: ${item.unitPrice} DZD`, 130, y);
      doc.text(`Total: ${item.total} DZD`, 170, y);
      y += 10;
    });
    
    // Add totals
    y += 10;
    doc.text(`Subtotal: ${proforma.subtotal} DZD`, 130, y);
    y += 10;
    doc.text(`VAT: ${proforma.vat} DZD`, 130, y);
    y += 10;
    doc.text(`Total Amount: ${proforma.totalAmount} DZD`, 130, y);
    
    // Add signature space
    y += 30;
    doc.text('Signature & Stamp:', 20, y);
    doc.line(20, y + 5, 80, y + 5);
    
    // Send PDF
    const pdfBuffer = doc.output('arraybuffer');
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename=proforma-${proforma.invoiceNumber}.pdf`);
    res.status(200).send(Buffer.from(pdfBuffer));
  } catch (error) {
    next(error);
  }
}; 

===== C:\Users\Badr Admin\Desktop\src\controllers\user.controller.ts =====
import { Request, Response, NextFunction } from 'express';
import { AuthRequest } from '../middleware/auth';
import { User } from '../models/user.model';
import { AppError } from '../utils/appError';
import bcrypt from 'bcryptjs';

const userController = {
  async login(req: Request, res: Response, next: NextFunction) {
    try {
      const { username, password } = req.body;

      if (!username || !password) {
        throw AppError.badRequest('Please provide username and password');
      }

      const user = await User.findOne({ username }).select('+password +isAuthorized');
      
      if (!user || !user.isAuthorized) {
        throw AppError.unauthorized('Invalid username or password');
      }

      const isPasswordValid = await user.comparePassword(password);
      if (!isPasswordValid) {
        throw AppError.unauthorized('Invalid username or password');
      }

      // Update last login
      user.lastLogin = new Date();
      await user.save({ validateBeforeSave: false });

      res.status(200).json({
        status: 'success',
        data: {
          user: {
            id: user._id,
            username: user.username,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role,
            isAuthorized: user.isAuthorized,
            lastLogin: user.lastLogin
          }
        }
      });
    } catch (error) {
      next(error);
    }
  },

  async register(req: Request, res: Response, next: NextFunction) {
    try {
      const { username, password, firstName, lastName, role } = req.body;

      // Check if username exists
      const existingUser = await User.findOne({ username });
      if (existingUser) {
        throw AppError.conflict('Username already in use');
      }

      // Create new user (not authorized by default)
      const newUser = await User.create({
        username,
        password,
        firstName,
        lastName,
        role: role || 'user',
        isAuthorized: false
      });

      res.status(201).json({
        status: 'success',
        message: 'User registered successfully. Waiting for admin authorization.',
        data: {
          user: {
            id: newUser._id,
            username: newUser.username,
            firstName: newUser.firstName,
            lastName: newUser.lastName,
            role: newUser.role,
            isAuthorized: newUser.isAuthorized
          }
        }
      });
    } catch (error) {
      next(error);
    }
  },

  async getProfile(req: AuthRequest, res: Response, next: NextFunction) {
    try {
      const user = await User.findById(req.user?.id).select('-password');
      if (!user) {
        throw AppError.notFound('User not found');
      }
      res.json(user);
    } catch (error) {
      next(error);
    }
  },

  async updateProfile(req: AuthRequest, res: Response, next: NextFunction) {
    try {
      const { password, ...userData } = req.body;
      const updateData = { ...userData };

      if (password) {
        updateData.password = await bcrypt.hash(password, 12);
      }

      const user = await User.findByIdAndUpdate(
        req.user?.id,
        updateData,
        { new: true, runValidators: true }
      ).select('-password');

      if (!user) {
        throw AppError.notFound('User not found');
      }

      res.json(user);
    } catch (error) {
      next(error);
    }
  },

  async getAll(req: Request, res: Response, next: NextFunction) {
    try {
      const users = await User.find().select('-password');
      res.json(users);
    } catch (error) {
      next(error);
    }
  },

  async getById(req: Request, res: Response, next: NextFunction) {
    try {
      const user = await User.findById(req.params.id).select('-password');
      if (!user) {
        throw AppError.notFound('User not found');
      }
      res.json(user);
    } catch (error) {
      next(error);
    }
  },

  async create(req: Request, res: Response, next: NextFunction) {
    try {
      const { password, ...userData } = req.body;
      const hashedPassword = await bcrypt.hash(password, 12);
      
      const user = await User.create({
        ...userData,
        password: hashedPassword,
        isAuthorized: true // Admin-created users are authorized by default
      });

      res.status(201).json(user);
    } catch (error) {
      next(error);
    }
  },

  async update(req: Request, res: Response, next: NextFunction) {
    try {
      const { password, ...userData } = req.body;
      const updateData = { ...userData };

      if (password) {
        updateData.password = await bcrypt.hash(password, 12);
      }

      const user = await User.findByIdAndUpdate(
        req.params.id,
        updateData,
        { new: true, runValidators: true }
      ).select('-password');

      if (!user) {
        throw AppError.notFound('User not found');
      }

      res.json(user);
    } catch (error) {
      next(error);
    }
  },

  async delete(req: Request, res: Response, next: NextFunction) {
    try {
      const user = await User.findByIdAndDelete(req.params.id);
      if (!user) {
        throw AppError.notFound('User not found');
      }
      res.status(204).send();
    } catch (error) {
      next(error);
    }
  },

  async authorizeUser(req: Request, res: Response, next: NextFunction) {
    try {
      const user = await User.findByIdAndUpdate(
        req.params.id,
        { isAuthorized: true },
        { new: true }
      ).select('-password');

      if (!user) {
        throw AppError.notFound('User not found');
      }

      res.json({
        status: 'success',
        message: 'User authorized successfully',
        data: { user }
      });
    } catch (error) {
      next(error);
    }
  }
};

export { userController };

===== C:\Users\Badr Admin\Desktop\src\interfaces\user.interface.ts =====
import { Document } from 'mongoose';

export interface IUser extends Document {
  username: string;
  password: string;
  firstName: string;
  lastName: string;
  role: 'admin' | 'user';
  isAuthorized: boolean;
  lastLogin?: Date;
  passwordResetToken?: string;
  passwordResetExpires?: Date;
  settings?: {
    theme: 'light' | 'dark';
    language: string;
    timezone: string;
  };
  comparePassword(candidatePassword: string): Promise<boolean>;
  createPasswordResetToken(): string;
  changedPasswordAfter(JWTTimestamp: number): boolean;
} 

===== C:\Users\Badr Admin\Desktop\src\middleware\auth.middleware.ts =====
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { User } from '../models/user.model';
import { AppError } from '../utils/appError';
import { config } from '../config';

// Extend Express Request type to include user
declare global {
  namespace Express {
    interface Request {
      user?: any;
    }
  }
}

export const authMiddleware = {
  protect: async (req: Request, res: Response, next: NextFunction) => {
    try {
      // 1) Getting token and check if it's there
      let token;
      if (
        req.headers.authorization &&
        req.headers.authorization.startsWith('Bearer')
      ) {
        token = req.headers.authorization.split(' ')[1];
      }

      if (!token) {
        return next(
          new AppError('You are not logged in! Please log in to get access.', 401)
        );
      }

      // 2) Verification token
      const decoded = jwt.verify(token, config.jwt.secret) as { id: string };

      // 3) Check if user still exists
      const currentUser = await User.findById(decoded.id);
      if (!currentUser) {
        return next(
          new AppError(
            'The user belonging to this token does no longer exist.',
            401
          )
        );
      }

      // 4) Check if user changed password after the token was issued
      if (currentUser.changedPasswordAfter(decoded.iat)) {
        return next(
          new AppError('User recently changed password! Please log in again.', 401)
        );
      }

      // 5) Check if user is authorized
      if (!currentUser.isAuthorized) {
        return next(
          new AppError('Your account is not yet authorized. Please wait for admin approval.', 401)
        );
      }

      // GRANT ACCESS TO PROTECTED ROUTE
      req.user = currentUser;
      next();
    } catch (error) {
      next(error);
    }
  },

  restrictTo: (...roles: string[]) => {
    return (req: Request, res: Response, next: NextFunction) => {
      if (!req.user) {
        return next(
          new AppError('You are not logged in! Please log in to get access.', 401)
        );
      }

      if (!roles.includes(req.user.role)) {
        return next(
          new AppError('You do not have permission to perform this action', 403)
        );
      }

      next();
    };
  }
}; 

===== C:\Users\Badr Admin\Desktop\src\middleware\auth.ts =====
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { config } from '../config';
import { User, IUser } from '../models/user.model';
import { AppError } from '../utils/appError';
import logger from '../utils/logger';

// Extend Express Request type to include user
declare global {
  namespace Express {
    interface Request {
      user?: IUser;
    }
  }
}

export interface AuthRequest extends Request {
  user?: IUser;
}

export const verifyToken = async (token: string): Promise<IUser> => {
  try {
    const decoded = jwt.verify(token, config.jwt.secret) as { id: string };
    const user = await User.findById(decoded.id).select('-password +active');
    if (!user) {
      throw AppError.unauthorized('User not found');
    }
    if (!user.isActive) {
      throw AppError.unauthorized('User is inactive');
    }
    return user;
  } catch (error) {
    throw AppError.unauthorized('Invalid token');
  }
};

export const protect = async (req: Request, _res: Response, next: NextFunction) => {
  try {
    // Get token from header or cookie
    let token;
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith('Bearer')
    ) {
      token = req.headers.authorization.split(' ')[1];
    } else if (req.cookies.jwt) {
      token = req.cookies.jwt;
    }

    if (!token) {
      return next(AppError.unauthorized('You are not logged in! Please log in to get access.'));
    }

    // Verify token
    const decoded = jwt.verify(token, config.jwt.secret) as { id: string };

    // Check if user exists
    const currentUser = await User.findById(decoded.id).select('+active');
    if (!currentUser) {
      return next(AppError.unauthorized('The user belonging to this token no longer exists.'));
    }

    // Check if user is active
    if (!currentUser.isActive) {
      return next(AppError.unauthorized('Your account is inactive. Please contact support.'));
    }

    // Log successful authentication
    logger.info('User authenticated successfully', {
      userId: currentUser._id,
      username: currentUser.username
    });

    // Grant access to protected route
    req.user = currentUser;
    next();
  } catch (error) {
    logger.error('Authentication error', { error });
    return next(AppError.unauthorized('Invalid token. Please log in again.'));
  }
};

export const restrictTo = (...roles: string[]) => {
  return (req: Request, _res: Response, next: NextFunction) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return next(AppError.forbidden('You do not have permission to perform this action'));
    }
    next();
  };
};

// Export protect as authMiddleware for backward compatibility
export const authMiddleware = protect;

===== C:\Users\Badr Admin\Desktop\src\middleware\compression.middleware.ts =====
import compression from 'compression';
import { Request, Response, NextFunction } from 'express';

const compressionConfig = {
  level: 6, // Compression level (0-9)
  threshold: 1024, // Only compress responses larger than 1KB
  filter: (req: Request, res: Response) => {
    if (req.headers['x-no-compression']) {
      return false;
    }
    return compression.filter(req, res);
  },
};

export const compressionMiddleware = compression(compressionConfig); 

===== C:\Users\Badr Admin\Desktop\src\middleware\cors.middleware.ts =====
import cors from 'cors';
import { Request, Response, NextFunction } from 'express';

const allowedOrigins = [
  'http://localhost:3000',
  'http://localhost:5173',
  'http://localhost:8080',
  process.env.FRONTEND_URL || '',
];

const corsOptions = {
  origin: (origin: string | undefined, callback: (err: Error | null, allow?: boolean) => void) => {
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true,
  maxAge: 86400, // 24 hours
};

export const corsMiddleware = cors(corsOptions); 

===== C:\Users\Badr Admin\Desktop\src\middleware\error.middleware.ts =====
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../utils/appError';
import { typedLogger } from '../utils/logger';

export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  if (err instanceof AppError) {
    return res.status(err.statusCode).json({
      status: err.status,
      message: err.message
    });
  }

  // Handle Mongoose validation errors
  if (err.name === 'ValidationError') {
    const errors = Object.values((err as any).errors).map((el: any) => el.message);
    const message = `Invalid input data. ${errors.join('. ')}`;
    return res.status(400).json({
      status: 'fail',
      message
    });
  }

  // Handle Mongoose duplicate key errors
  if ((err as any).code === 11000) {
    const value = (err as any).errmsg.match(/(["'])(\\?.)*?\1/)[0];
    const message = `Duplicate field value: ${value}. Please use another value!`;
    return res.status(400).json({
      status: 'fail',
      message
    });
  }

  // Handle JWT errors
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({
      status: 'fail',
      message: 'Invalid token. Please log in again!'
    });
  }

  if (err.name === 'TokenExpiredError') {
    return res.status(401).json({
      status: 'fail',
      message: 'Your token has expired! Please log in again.'
    });
  }

  // Log unexpected errors
  typedLogger.error('Unexpected error:', err);

  // Send generic error response
  return res.status(500).json({
    status: 'error',
    message: 'Something went wrong!'
  });
}; 

===== C:\Users\Badr Admin\Desktop\src\middleware\errorHandler.ts =====
import { Request, Response, NextFunction } from 'express';
import { ApiError } from '../types/error';
import logger from '../utils/logger';

export const errorHandler = (
  err: ApiError,
  req: Request,
  res: Response,
  _next: NextFunction
) => {
  const status = err.status || 500;
  const message = err.message || 'Internal Server Error';

  logger.error({
    message,
    status,
    stack: err.stack,
    path: req.path,
    method: req.method,
    timestamp: new Date().toISOString()
  });

  res.status(status).json({
    status: 'error',
    message,
    code: err.code,
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
};

===== C:\Users\Badr Admin\Desktop\src\middleware\helmet.middleware.ts =====
import helmet from 'helmet';
import { Request, Response, NextFunction } from 'express';

const helmetConfig = {
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", 'data:', 'blob:'],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },
  crossOriginEmbedderPolicy: true,
  crossOriginOpenerPolicy: true,
  crossOriginResourcePolicy: { policy: 'same-site' },
  dnsPrefetchControl: { allow: false },
  frameguard: { action: 'deny' },
  hidePoweredBy: true,
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true,
  },
  ieNoOpen: true,
  noSniff: true,
  originAgentCluster: true,
  permittedCrossDomainPolicies: { permittedPolicies: 'none' },
  referrerPolicy: { policy: 'no-referrer' },
  xssFilter: true,
};

export const helmetMiddleware = helmet(helmetConfig); 

===== C:\Users\Badr Admin\Desktop\src\middleware\morgan.middleware.ts =====
import morgan from 'morgan';
import { Request, Response, NextFunction } from 'express';
import logger from '../utils/logger';

const stream = {
  write: (message: string) => {
    logger.info(message.trim());
  },
};

const skip = () => {
  const env = process.env.NODE_ENV || 'development';
  return env !== 'development';
};

const morganConfig = {
  stream,
  skip,
};

export const morganMiddleware = morgan(
  ':remote-addr :method :url :status :res[content-length] - :response-time ms',
  morganConfig
); 

===== C:\Users\Badr Admin\Desktop\src\middleware\notFoundHandler.ts =====
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../utils/appError';

export const notFoundHandler = (
  req: Request,
  _res: Response,
  next: NextFunction
) => {
  console.warn(`Route not found: ${req.method} ${req.originalUrl}`);
  next(new AppError(`Route ${req.originalUrl} not found`, 404));
};

===== C:\Users\Badr Admin\Desktop\src\middleware\rateLimit.middleware.ts =====
import { Request, Response, NextFunction } from 'express';
import rateLimit from 'express-rate-limit';
import { AppError } from '../utils/appError';

export const createRateLimiter = (options: {
  windowMs: number;
  max: number;
  message?: string;
}) => {
  return rateLimit({
    windowMs: options.windowMs,
    max: options.max,
    message: options.message || 'Too many requests, please try again later.',
    handler: (req: Request, res: Response) => {
      throw AppError.rateLimitExceeded();
    },
  });
};

export const apiLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
});

export const authLimiter = createRateLimiter({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 5, // limit each IP to 5 requests per windowMs
  message: 'Too many login attempts, please try again later.',
}); 

===== C:\Users\Badr Admin\Desktop\src\middleware\rateLimit.ts =====
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import Redis from 'ioredis';
import logger from '../utils/logger';

const redisClient = new Redis(process.env.REDIS_URL);

redisClient.on('error', (err) => {
  logger.error('Redis Error:', err);
});

export const createRateLimiter = (options: {
  windowMs?: number;
  max?: number;
  message?: string;
}) => {
  return rateLimit({
    store: new RedisStore({
      client: redisClient,
      prefix: 'rate-limit:',
    }),
    windowMs: options.windowMs || 15 * 60 * 1000,
    max: options.max || 100,
    message: options.message || 'Too many requests, please try again later',
    standardHeaders: true,
    legacyHeaders: false,
  });
};

export const loginLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: 'Too many login attempts, please try again after 15 minutes'
});

export const apiLimiter = createRateLimiter({
  windowMs: 60 * 1000,
  max: 60
});


===== C:\Users\Badr Admin\Desktop\src\middleware\security.ts =====
import { Request, Response, NextFunction } from 'express';
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import hpp from 'hpp';
import mongoSanitize from 'express-mongo-sanitize';

export const securityMiddleware = [
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
        styleSrc: ["'self'", "'unsafe-inline'", "https:", "http:"],
        imgSrc: ["'self'", 'data:', 'https:', 'http:', 'blob:'],
        connectSrc: ["'self'", 'ws:', 'wss:', 'https:', 'http:'],
        fontSrc: ["'self'", 'data:', 'https:', 'http:'],
        objectSrc: ["'none'"],
        mediaSrc: ["'self'"],
        frameSrc: ["'self'"],
      },
    },
    crossOriginEmbedderPolicy: false,
    crossOriginOpenerPolicy: false,
    crossOriginResourcePolicy: { policy: 'cross-origin' },
  }),
  mongoSanitize(),
  hpp(),
  rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100,
    message: 'Too many requests, please try again later.',
  })
];


===== C:\Users\Badr Admin\Desktop\src\middleware\upload.middleware.ts =====
import multer from 'multer';
import path from 'path';
import fs from 'fs';

// Create uploads directory if it doesn't exist
const uploadsDir = path.join(__dirname, '../../uploads');
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}

// Configure storage
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    let uploadPath = uploadsDir;

    // Determine subdirectory based on file type
    if (file.fieldname === 'logo') {
      uploadPath = path.join(uploadsDir, 'logos');
    } else if (file.fieldname === 'signature') {
      uploadPath = path.join(uploadsDir, 'signatures');
    }

    // Create subdirectory if it doesn't exist
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }

    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    // Generate unique filename
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  },
});

// Configure file filter
const fileFilter = (req: Express.Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  // Allow only images for logo and signature
  if (file.fieldname === 'logo' || file.fieldname === 'signature') {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only image files are allowed'));
    }
  } else {
    cb(null, true);
  }
};

// Create multer instance
export const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB limit
  },
}); 

===== C:\Users\Badr Admin\Desktop\src\middleware\validateRequest.middleware.ts =====
import { Request, Response, NextFunction } from 'express';
import { Schema } from 'joi';
import { AppError } from '../utils/appError';

export const validateRequest = (schema: Schema) => {
  return (req: Request, _res: Response, next: NextFunction) => {
    const { error } = schema.validate(req.body, {
      abortEarly: false,
      stripUnknown: true,
    });

    if (error) {
      const errorMessage = error.details
        .map((detail) => detail.message)
        .join(', ');
      return next(new AppError(400, 'Invalid request body: ' + errorMessage));
    }

    next();
  };
}; 

===== C:\Users\Badr Admin\Desktop\src\middleware\validateRequest.ts =====
import { Request, Response, NextFunction } from 'express';
import { validationResult } from 'express-validator';
import { AppError } from '../utils/appError';

export const validateRequest = (
  req: Request,
  _res: Response,
  next: NextFunction
) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const errorMessage = errors.array().map(err => err.msg).join(', ');
    return next(new AppError('Invalid request body: ' + errorMessage, 400));
  }
  next();
};

===== C:\Users\Badr Admin\Desktop\src\middleware\validation.middleware.ts =====
import { Request, Response, NextFunction } from 'express';
import { ValidationError } from 'joi';

interface ValidationErrorResponse {
  status: string;
  message: string;
  errors?: string[];
}

export const validateRequest = (schema: any) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const { error } = schema.validate(req.body, { abortEarly: false });

    if (error) {
      const response: ValidationErrorResponse = {
        status: 'error',
        message: 'Validation failed',
        errors: error.details.map((detail: { message: string }) => detail.message)
      };
      return res.status(400).json(response);
    }

    next();
  };
};

export const errorHandler = (
  error: Error | ValidationError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  if (error instanceof ValidationError) {
    const response: ValidationErrorResponse = {
      status: 'error',
      message: 'Validation failed',
      errors: error.details.map((detail) => detail.message)
    };
    return res.status(400).json(response);
  }

  // Handle other types of errors
  res.status(500).json({
    status: 'error',
    message: 'Internal server error'
  });
}; 

===== C:\Users\Badr Admin\Desktop\src\middleware\validation.ts =====
import { Request, NextFunction, RequestHandler } from 'express';
import { validationResult, ValidationChain } from 'express-validator';
import { ApiError } from '../types/error';

export const validate = (validations: ValidationChain[]): RequestHandler => {
  return async (req: Request, _res: any, next: NextFunction) => {
    await Promise.all(validations.map(validation => validation.run(req)));

    const errors = validationResult(req);
    if (errors.isEmpty()) {
      return next();
    }

    const error = new ApiError(
      'Validation error',
      400,
      'VALIDATION_ERROR'
    );
    error.details = errors.array();
    next(error);
  };
};


===== C:\Users\Badr Admin\Desktop\src\models\analytics.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';

interface IAnalytics extends Document {
  metric: string;
  value: number;
  timestamp: Date;
  metadata: Record<string, any>;
  tags: string[];
}

const analyticsSchema = new Schema<IAnalytics>({
  metric: { type: String, required: true, index: true },
  value: { type: Number, required: true },
  timestamp: { type: Date, default: Date.now, index: true },
  metadata: { type: Schema.Types.Mixed },
  tags: [{ type: String, index: true }]
});

analyticsSchema.index({ metric: 1, timestamp: -1 });

export const Analytics = mongoose.model<IAnalytics>('Analytics', analyticsSchema);


===== C:\Users\Badr Admin\Desktop\src\models\company.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';

export interface ICompany extends Document {
  name: string;
  address: string;
  phone: string;
  email: string;
  website?: string;
  logo?: string;
  taxId?: string;
  createdAt: Date;
  updatedAt: Date;
}

const companySchema = new Schema<ICompany>(
  {
    name: {
      type: String,
      required: [true, 'Company name is required'],
      trim: true,
    },
    address: {
      type: String,
      required: [true, 'Company address is required'],
      trim: true,
    },
    phone: {
      type: String,
      required: [true, 'Company phone is required'],
      trim: true,
    },
    email: {
      type: String,
      required: [true, 'Company email is required'],
      trim: true,
      lowercase: true,
    },
    website: {
      type: String,
      trim: true,
    },
    logo: {
      type: String,
    },
    taxId: {
      type: String,
      trim: true,
    },
  },
  {
    timestamps: true,
  }
);

// Create indexes
companySchema.index({ nif: 1 }, { unique: true });

export const Company = mongoose.model<ICompany>('Company', companySchema); 

===== C:\Users\Badr Admin\Desktop\src\models\contract.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';

export interface IContract extends Document {
  contractNumber: string;
  contractType: string;
  partyA: {
    name: string;
    address: string;
    contactPerson: string;
    email: string;
    phone: string;
  };
  partyB: {
    name: string;
    address: string;
    contactPerson: string;
    email: string;
    phone: string;
  };
  terms: string;
  startDate: Date;
  endDate: Date;
  value: number;
  status: 'draft' | 'active' | 'expired' | 'terminated';
  attachments: Array<{
    name: string;
    url: string;
    type: string;
  }>;
  createdAt: Date;
  updatedAt: Date;
  createdBy: mongoose.Types.ObjectId;
}

const contractSchema = new Schema<IContract>(
  {
    contractNumber: {
      type: String,
      required: true,
      unique: true,
    },
    contractType: {
      type: String,
      required: true,
    },
    partyA: {
      name: {
        type: String,
        required: true,
      },
      address: {
        type: String,
        required: true,
      },
      contactPerson: {
        type: String,
        required: true,
      },
      email: {
        type: String,
        required: true,
      },
      phone: {
        type: String,
        required: true,
      },
    },
    partyB: {
      name: {
        type: String,
        required: true,
      },
      address: {
        type: String,
        required: true,
      },
      contactPerson: {
        type: String,
        required: true,
      },
      email: {
        type: String,
        required: true,
      },
      phone: {
        type: String,
        required: true,
      },
    },
    terms: {
      type: String,
      required: true,
    },
    startDate: {
      type: Date,
      required: true,
    },
    endDate: {
      type: Date,
      required: true,
    },
    value: {
      type: Number,
      required: true,
      min: 0,
    },
    status: {
      type: String,
      enum: ['draft', 'active', 'expired', 'terminated'],
      default: 'draft',
    },
    attachments: [{
      name: {
        type: String,
        required: true,
      },
      url: {
        type: String,
        required: true,
      },
      type: {
        type: String,
        required: true,
      },
    }],
    createdBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
  },
  {
    timestamps: true,
  }
);

const Contract = mongoose.model<IContract>('Contract', contractSchema);

export default Contract;


===== C:\Users\Badr Admin\Desktop\src\models\inventory.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';
import { IStockCategory } from '../modules/stock/models/stockCategory.model';
import { ISupplier } from '../modules/stock/models/supplier.model';

export interface IInventoryItem extends Document {
  name: string;
  description?: string;
  sku: string;
  category: IStockCategory['_id'];
  supplier: ISupplier['_id'];
  quantity: number;
  unitPrice: number;
  minStockLevel: number;
  valuationMethod: 'FIFO' | 'LIFO' | 'Average';
  location?: string;
  status: 'active' | 'discontinued';
  lastRestocked?: Date;
  createdAt: Date;
  updatedAt: Date;
}

const inventorySchema = new Schema<IInventoryItem>(
  {
    name: {
      type: String,
      required: [true, 'Item name is required'],
      trim: true,
    },
    description: {
      type: String,
      trim: true,
    },
    sku: {
      type: String,
      required: [true, 'SKU is required'],
      unique: true,
      trim: true,
    },
    category: {
      type: Schema.Types.ObjectId,
      ref: 'StockCategory',
      required: [true, 'Category is required'],
    },
    supplier: {
      type: Schema.Types.ObjectId,
      ref: 'Supplier',
      required: [true, 'Supplier is required'],
    },
    quantity: {
      type: Number,
      required: [true, 'Quantity is required'],
      min: [0, 'Quantity cannot be negative'],
      default: 0,
    },
    unitPrice: {
      type: Number,
      required: [true, 'Unit price is required'],
      min: [0, 'Unit price cannot be negative'],
    },
    minStockLevel: {
      type: Number,
      required: [true, 'Minimum stock level is required'],
      min: [0, 'Minimum stock level cannot be negative'],
      default: 0,
    },
    valuationMethod: {
      type: String,
      enum: ['FIFO', 'LIFO', 'Average'],
      default: 'FIFO',
    },
    location: {
      type: String,
      trim: true,
    },
    status: {
      type: String,
      enum: ['active', 'discontinued'],
      default: 'active',
    },
    lastRestocked: {
      type: Date,
    },
  },
  {
    timestamps: true,
  }
);

// Create indexes for faster queries
inventorySchema.index({ sku: 1 });
inventorySchema.index({ category: 1 });
inventorySchema.index({ supplier: 1 });
inventorySchema.index({ status: 1 });

// Virtual for stock value
inventorySchema.virtual('stockValue').get(function() {
  return this.quantity * this.unitPrice;
});

// Virtual for stock status
inventorySchema.virtual('stockStatus').get(function() {
  if (this.quantity <= 0) return 'out_of_stock';
  if (this.quantity <= this.minStockLevel) return 'low_stock';
  return 'in_stock';
});

export const InventoryItem = mongoose.model<IInventoryItem>('InventoryItem', inventorySchema); 

===== C:\Users\Badr Admin\Desktop\src\models\invoice.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';

export interface IInvoice extends Document {
  invoiceNumber: string;
  type: 'proforma' | 'final';
  company: {
    name: string;
    address: string;
    nif: string;
  };
  client: {
    name: string;
    address: string;
    nif?: string;
  };
  items: Array<{
    description: string;
    quantity: number;
    unitPrice: number;
    total: number;
    barcode?: string;
  }>;
  subtotal: number;
  vatRate: number;
  vatAmount: number;
  total: number;
  paymentTerms: string;
  status: 'draft' | 'validated' | 'cancelled';
  dueDate: Date;
  signature?: string;
  qrCode?: string;
  createdAt: Date;
  updatedAt: Date;
  createdBy: mongoose.Types.ObjectId;
}

const invoiceSchema = new Schema<IInvoice>(
  {
    invoiceNumber: {
      type: String,
      required: true,
      unique: true,
    },
    type: {
      type: String,
      enum: ['proforma', 'final'],
      required: true,
    },
    company: {
      name: {
        type: String,
        required: true,
      },
      address: {
        type: String,
        required: true,
      },
      nif: {
        type: String,
        required: true,
      },
    },
    client: {
      name: {
        type: String,
        required: true,
      },
      address: {
        type: String,
        required: true,
      },
      nif: {
        type: String,
      },
    },
    items: [{
      description: {
        type: String,
        required: true,
      },
      quantity: {
        type: Number,
        required: true,
        min: 0,
      },
      unitPrice: {
        type: Number,
        required: true,
        min: 0,
      },
      total: {
        type: Number,
        required: true,
        min: 0,
      },
      barcode: {
        type: String,
      },
    }],
    subtotal: {
      type: Number,
      required: true,
      min: 0,
    },
    vatRate: {
      type: Number,
      required: true,
      min: 0,
    },
    vatAmount: {
      type: Number,
      required: true,
      min: 0,
    },
    total: {
      type: Number,
      required: true,
      min: 0,
    },
    paymentTerms: {
      type: String,
      required: true,
    },
    status: {
      type: String,
      enum: ['draft', 'validated', 'cancelled'],
      default: 'draft',
    },
    dueDate: {
      type: Date,
      required: true,
    },
    signature: {
      type: String,
    },
    qrCode: {
      type: String,
    },
    createdBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
  },
  {
    timestamps: true,
  }
);

// Pre-save middleware to calculate totals
invoiceSchema.pre('save', function(next) {
  // Calculate item totals
  this.items.forEach(item => {
    item.total = item.quantity * item.unitPrice;
  });

  // Calculate subtotal
  this.subtotal = this.items.reduce((sum, item) => sum + item.total, 0);

  // Calculate VAT amount
  this.vatAmount = this.subtotal * (this.vatRate / 100);

  // Calculate total with VAT
  this.total = this.subtotal + this.vatAmount;

  next();
});

const Invoice = mongoose.model<IInvoice>('Invoice', invoiceSchema);

export default Invoice; 

===== C:\Users\Badr Admin\Desktop\src\models\license.model.ts =====
import { Schema, model, Document } from 'mongoose';

export interface ILicense extends Document {
  name: string;
  key: string;
  status: 'active' | 'inactive' | 'expired';
  expiryDate: Date;
  maxUsers: number;
  features: string[];
  createdAt: Date;
  updatedAt: Date;
}

const licenseSchema = new Schema({
  name: { type: String, required: true },
  key: { type: String, required: true, unique: true },
  status: { 
    type: String, 
    enum: ['active', 'inactive', 'expired'],
    default: 'active'
  },
  expiryDate: { type: Date, required: true },
  maxUsers: { type: Number, required: true, default: 1 },
  features: [{ type: String }],
}, {
  timestamps: true
});

export default model<ILicense>('License', licenseSchema); 

===== C:\Users\Badr Admin\Desktop\src\models\proforma.model.ts =====
import mongoose, { Document, Schema } from 'mongoose';

export interface IProformaItem {
  description: string;
  quantity: number;
  unitPrice: number;
  total: number;
  barcode?: string;
}

export interface IProforma extends Document {
  invoiceNumber: string;
  date: Date;
  company: {
    name: string;
    address: string;
    nif: string;
  };
  client: {
    name: string;
    address: string;
    nif?: string;
  };
  items: IProformaItem[];
  subtotal: number;
  vatRate: number;
  vatAmount: number;
  totalAmount: number;
  paymentTerms: string;
  status: 'draft' | 'finalized';
  signature?: string;
  qrCode?: string;
  createdBy: mongoose.Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const proformaSchema = new Schema<IProforma>(
  {
    invoiceNumber: {
      type: String,
      required: [true, 'Invoice number is required'],
      unique: true,
    },
    date: {
      type: Date,
      required: [true, 'Date is required'],
      default: Date.now,
    },
    company: {
      name: {
        type: String,
        required: [true, 'Company name is required'],
      },
      address: {
        type: String,
        required: [true, 'Company address is required'],
      },
      nif: {
        type: String,
        required: [true, 'Company NIF is required'],
      },
    },
    client: {
      name: {
        type: String,
        required: [true, 'Client name is required'],
      },
      address: {
        type: String,
        required: [true, 'Client address is required'],
      },
      nif: {
        type: String,
      },
    },
    items: [{
      description: {
        type: String,
        required: [true, 'Item description is required'],
      },
      quantity: {
        type: Number,
        required: [true, 'Quantity is required'],
        min: [1, 'Quantity must be at least 1'],
      },
      unitPrice: {
        type: Number,
        required: [true, 'Unit price is required'],
        min: [0, 'Unit price must be positive'],
      },
      total: {
        type: Number,
        required: [true, 'Total is required'],
      },
      barcode: {
        type: String,
      },
    }],
    subtotal: {
      type: Number,
      required: [true, 'Subtotal is required'],
      min: [0, 'Subtotal must be positive'],
    },
    vatRate: {
      type: Number,
      required: [true, 'VAT rate is required'],
      min: [0, 'VAT rate must be positive'],
    },
    vatAmount: {
      type: Number,
      required: [true, 'VAT amount is required'],
      min: [0, 'VAT amount must be positive'],
    },
    totalAmount: {
      type: Number,
      required: [true, 'Total amount is required'],
      min: [0, 'Total amount must be positive'],
    },
    paymentTerms: {
      type: String,
      required: [true, 'Payment terms are required'],
    },
    status: {
      type: String,
      enum: ['draft', 'finalized'],
      default: 'draft',
    },
    signature: {
      type: String,
    },
    qrCode: {
      type: String,
    },
    createdBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: [true, 'Creator is required'],
    },
  },
  {
    timestamps: true,
  }
);

// Pre-save middleware to calculate totals
proformaSchema.pre('save', function(next) {
  // Calculate item totals
  this.items.forEach(item => {
    item.total = item.quantity * item.unitPrice;
  });

  // Calculate subtotal
  this.subtotal = this.items.reduce((sum, item) => sum + item.total, 0);

  // Calculate VAT amount
  this.vatAmount = this.subtotal * (this.vatRate / 100);

  // Calculate total amount with VAT
  this.totalAmount = this.subtotal + this.vatAmount;

  next();
});

export default mongoose.model<IProforma>('Proforma', proformaSchema); 

===== C:\Users\Badr Admin\Desktop\src\models\user.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';
import bcrypt from 'bcryptjs';
import crypto from 'crypto';
import { typedLogger } from '../utils/logger';

export type UserRole = 'admin' | 'user';

export interface IUser extends Document {
  username: string;
  password: string;
  firstName: string;
  lastName: string;
  role: UserRole;
  isAuthorized: boolean;
  isActive: boolean;
  lastLogin?: Date;
  passwordChangedAt?: Date;
  passwordResetToken?: string;
  passwordResetExpires?: Date;
  settings: {
    theme: 'light' | 'dark';
    language: string;
    timezone: string;
  };
  comparePassword(candidatePassword: string): Promise<boolean>;
  createPasswordResetToken(): string;
  changedPasswordAfter(JWTTimestamp: number): boolean;
}

const userSchema = new Schema<IUser>(
  {
    username: {
      type: String,
      required: [true, 'Please provide a username'],
      unique: true,
      trim: true,
      minlength: [3, 'Username must be at least 3 characters long']
    },
    password: {
      type: String,
      required: [true, 'Please provide a password'],
      minlength: [8, 'Password must be at least 8 characters long'],
      select: false
    },
    firstName: {
      type: String,
      required: [true, 'Please provide your first name']
    },
    lastName: {
      type: String,
      required: [true, 'Please provide your last name']
    },
    role: {
      type: String,
      enum: ['admin', 'user'],
      default: 'user'
    },
    isAuthorized: {
      type: Boolean,
      default: false
    },
    isActive: {
      type: Boolean,
      default: true
    },
    lastLogin: {
      type: Date
    },
    passwordChangedAt: Date,
    passwordResetToken: String,
    passwordResetExpires: Date,
    settings: {
      theme: {
        type: String,
        enum: ['light', 'dark'],
        default: 'light'
      },
      language: {
        type: String,
        default: 'en'
      },
      timezone: {
        type: String,
        default: 'UTC'
      }
    }
  },
  {
    timestamps: true
  }
);

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  try {
    this.password = await bcrypt.hash(this.password, 12);
    next();
  } catch (error) {
    typedLogger.error('Error hashing password:', { error });
    next(error as Error);
  }
});

// Compare password method
userSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
  try {
    return await bcrypt.compare(candidatePassword, this.password);
  } catch (error) {
    typedLogger.error('Error comparing passwords:', { error });
    return false;
  }
};

// Create password reset token
userSchema.methods.createPasswordResetToken = function(): string {
  const resetToken = crypto.randomBytes(32).toString('hex');
  
  this.passwordResetToken = crypto
    .createHash('sha256')
    .update(resetToken)
    .digest('hex');
  
  this.passwordResetExpires = Date.now() + 10 * 60 * 1000; // 10 minutes
  
  return resetToken;
};

// Check if password was changed after token was issued
userSchema.methods.changedPasswordAfter = function(JWTTimestamp: number): boolean {
  if (this.passwordChangedAt) {
    const changedTimestamp = parseInt(
      (this.passwordChangedAt.getTime() / 1000).toString(),
      10
    );
    return JWTTimestamp < changedTimestamp;
  }
  return false;
};

export const User = mongoose.model<IUser>('User', userSchema);

===== C:\Users\Badr Admin\Desktop\src\modules\accounting\controllers\expense.controller.ts =====
import { Request, Response } from 'express';
import { Expense } from '../models/expense.model';
import { StatusManagementService } from '../../../shared/services/statusManagement.service';
import { ApiError } from '../../../shared/utils/ApiError';
import { ApiResponse } from '../../../shared/utils/ApiResponse';

const statusManagementService = new StatusManagementService();

export class ExpenseController {
  // Get all expenses with optional filters
  async getExpenses(req: Request, res: Response) {
    try {
      const {
        departmentId,
        category,
        status,
        startDate,
        endDate,
        includeDeleted = false
      } = req.query;

      const query: any = {};

      if (!includeDeleted) {
        query.isDeleted = false;
      }

      if (departmentId) {
        query.departmentId = departmentId;
      }

      if (category) {
        query.category = category;
      }

      if (status) {
        query.status = status;
      }

      if (startDate || endDate) {
        query.date = {};
        if (startDate) {
          query.date.$gte = new Date(startDate as string);
        }
        if (endDate) {
          query.date.$lte = new Date(endDate as string);
        }
      }

      const expenses = await Expense.find(query)
        .populate('createdBy', 'firstName lastName email')
        .populate('departmentId', 'name')
        .populate('approvedBy', 'firstName lastName email')
        .populate('rejectedBy', 'firstName lastName email')
        .populate('cancelledBy', 'firstName lastName email')
        .populate('voidedBy', 'firstName lastName email')
        .populate('deletedBy', 'firstName lastName email')
        .sort({ createdAt: -1 });

      return res.json(new ApiResponse(200, 'Expenses retrieved successfully', expenses));
    } catch (error) {
      throw new ApiError(500, 'Failed to retrieve expenses');
    }
  }

  // Create a new expense
  async createExpense(req: Request, res: Response) {
    try {
      const expense = new Expense({
        ...req.body,
        createdBy: req.user._id
      });

      await expense.save();
      await expense.populate('createdBy', 'firstName lastName email');
      await expense.populate('departmentId', 'name');

      return res.status(201).json(new ApiResponse(201, 'Expense created successfully', expense));
    } catch (error) {
      throw new ApiError(500, 'Failed to create expense');
    }
  }

  // Update expense status
  async updateExpenseStatus(req: Request, res: Response) {
    try {
      const { id } = req.params;
      const { status, reason } = req.body;
      const userId = req.user._id;

      const expense = await Expense.findById(id);
      if (!expense) {
        throw new ApiError(404, 'Expense not found');
      }

      if (expense.isDeleted) {
        throw new ApiError(400, 'Cannot update deleted expense');
      }

      // Update status using status management service
      await statusManagementService.changeStatus(
        'expenses',
        id,
        status,
        `EXPENSE_${status.toUpperCase()}`,
        reason,
        userId
      );

      // Update expense status and related fields
      expense.status = status;
      expense.reason = reason;
      expense[`${status}By`] = userId;
      expense[`${status}At`] = new Date();

      await expense.save();
      await expense.populate(`${status}By`, 'firstName lastName email');

      return res.json(new ApiResponse(200, 'Expense status updated successfully', expense));
    } catch (error) {
      throw new ApiError(500, 'Failed to update expense status');
    }
  }

  // Soft delete an expense
  async softDeleteExpense(req: Request, res: Response) {
    try {
      const { id } = req.params;
      const userId = req.user._id;

      const expense = await Expense.findById(id);
      if (!expense) {
        throw new ApiError(404, 'Expense not found');
      }

      if (expense.isDeleted) {
        throw new ApiError(400, 'Expense is already deleted');
      }

      if (expense.status === 'approved') {
        throw new ApiError(400, 'Cannot delete approved expense');
      }

      await expense.softDelete(userId);
      await expense.populate('deletedBy', 'firstName lastName email');

      return res.json(new ApiResponse(200, 'Expense deleted successfully', expense));
    } catch (error) {
      throw new ApiError(500, 'Failed to delete expense');
    }
  }

  // Restore a soft deleted expense
  async restoreExpense(req: Request, res: Response) {
    try {
      const { id } = req.params;

      const expense = await Expense.findById(id);
      if (!expense) {
        throw new ApiError(404, 'Expense not found');
      }

      if (!expense.isDeleted) {
        throw new ApiError(400, 'Expense is not deleted');
      }

      await expense.restore();

      return res.json(new ApiResponse(200, 'Expense restored successfully', expense));
    } catch (error) {
      throw new ApiError(500, 'Failed to restore expense');
    }
  }

  // Get a single expense by ID
  async getExpenseById(req: Request, res: Response) {
    try {
      const { id } = req.params;
      const { includeDeleted = false } = req.query;

      const query: any = { _id: id };
      if (!includeDeleted) {
        query.isDeleted = false;
      }

      const expense = await Expense.findOne(query)
        .populate('createdBy', 'firstName lastName email')
        .populate('departmentId', 'name')
        .populate('approvedBy', 'firstName lastName email')
        .populate('rejectedBy', 'firstName lastName email')
        .populate('cancelledBy', 'firstName lastName email')
        .populate('voidedBy', 'firstName lastName email')
        .populate('deletedBy', 'firstName lastName email');

      if (!expense) {
        throw new ApiError(404, 'Expense not found');
      }

      return res.json(new ApiResponse(200, 'Expense retrieved successfully', expense));
    } catch (error) {
      throw new ApiError(500, 'Failed to retrieve expense');
    }
  }
} 

===== C:\Users\Badr Admin\Desktop\src\modules\accounting\controllers\invoiceAccessToken.controller.ts =====
import { Request, Response, NextFunction } from 'express';
import { InvoiceAccessToken } from '../models/invoiceAccessToken.model';
import { Invoice } from '../models/invoice.model';
import { AppError } from '../../../utils/appError';
import { catchAsync } from '../../../utils/catchAsync';

// Request access token
export const requestAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { invoice, operation, details } = req.body;

  // Check if invoice exists
  const invoiceDoc = await Invoice.findById(invoice);
  if (!invoiceDoc) {
    return next(new AppError('Invoice not found', 404));
  }

  // Validate operation based on current status
  if (operation === 'payment') {
    if (!details.amount || details.amount <= 0) {
      return next(new AppError('Valid payment amount is required', 400));
    }
    
    if (!details.paymentMethod) {
      return next(new AppError('Payment method is required', 400));
    }
    
    // Check if invoice is already paid
    if (invoiceDoc.status === 'paid') {
      return next(new AppError('Invoice is already paid', 400));
    }
  }

  if (operation === 'cancellation') {
    if (!details.reason) {
      return next(new AppError('Reason is required for cancellation', 400));
    }
    
    // Check if invoice can be cancelled
    if (['paid', 'cancelled'].includes(invoiceDoc.status)) {
      return next(new AppError('Invoice cannot be cancelled in its current state', 400));
    }
  }

  if (operation === 'approval' && invoiceDoc.status !== 'pending') {
    return next(new AppError('Only pending invoices can be approved', 400));
  }

  // Check for existing active tokens
  const existingToken = await InvoiceAccessToken.findOne({
    invoice,
    status: 'active'
  });

  if (existingToken) {
    return next(new AppError('Another user is currently accessing this invoice', 409));
  }

  // Create new access token
  const token = await InvoiceAccessToken.create({
    invoice,
    user: req.user._id,
    operation,
    details,
    expiresAt: new Date(Date.now() + 5 * 60 * 1000) // 5 minutes expiration
  });

  res.status(201).json({
    status: 'success',
    data: {
      token: {
        token: token.token,
        expiresAt: token.expiresAt,
        operation: token.operation,
        details: token.details
      }
    }
  });
});

// Release access token
export const releaseAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { token } = req.params;

  const accessToken = await InvoiceAccessToken.findOne({ token });
  if (!accessToken) {
    return next(new AppError('Access token not found', 404));
  }

  if (accessToken.user.toString() !== req.user._id.toString()) {
    return next(new AppError('Not authorized to release this token', 403));
  }

  accessToken.status = 'completed';
  await accessToken.save();

  res.status(200).json({
    status: 'success',
    data: null
  });
});

// Cancel access token
export const cancelAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { token } = req.params;

  const accessToken = await InvoiceAccessToken.findOne({ token });
  if (!accessToken) {
    return next(new AppError('Access token not found', 404));
  }

  if (accessToken.user.toString() !== req.user._id.toString()) {
    return next(new AppError('Not authorized to cancel this token', 403));
  }

  accessToken.status = 'cancelled';
  await accessToken.save();

  res.status(200).json({
    status: 'success',
    data: null
  });
});

// Get active access token for an invoice
export const getActiveAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { invoice } = req.params;

  const accessToken = await InvoiceAccessToken.findOne({
    invoice,
    status: 'active'
  });

  if (!accessToken) {
    return next(new AppError('No active access token found for this invoice', 404));
  }

  res.status(200).json({
    status: 'success',
    data: {
      token: {
        token: accessToken.token,
        expiresAt: accessToken.expiresAt,
        operation: accessToken.operation,
        details: accessToken.details
      }
    }
  });
}); 

===== C:\Users\Badr Admin\Desktop\src\modules\accounting\models\expense.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';

export interface IExpense extends Document {
  amount: number;
  category: string;
  description: string;
  date: Date;
  createdBy: mongoose.Types.ObjectId;
  departmentId: mongoose.Types.ObjectId;
  status: 'pending' | 'approved' | 'rejected' | 'cancelled' | 'void';
  approvedBy?: mongoose.Types.ObjectId;
  approvedAt?: Date;
  rejectedBy?: mongoose.Types.ObjectId;
  rejectedAt?: Date;
  cancelledBy?: mongoose.Types.ObjectId;
  cancelledAt?: Date;
  voidedBy?: mongoose.Types.ObjectId;
  voidedAt?: Date;
  reason?: string;
  attachments?: {
    type: string;
    url: string;
  }[];
  isDeleted: boolean;
  deletedBy?: mongoose.Types.ObjectId;
  deletedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}

const expenseSchema = new Schema({
  amount: {
    type: Number,
    required: true,
    min: [0, 'Amount cannot be negative']
  },
  category: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    required: true,
    trim: true
  },
  date: {
    type: Date,
    required: true,
    default: Date.now
  },
  createdBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  departmentId: {
    type: Schema.Types.ObjectId,
    ref: 'Department',
    required: true
  },
  status: {
    type: String,
    enum: ['pending', 'approved', 'rejected', 'cancelled', 'void'],
    default: 'pending'
  },
  approvedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User'
  },
  approvedAt: Date,
  rejectedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User'
  },
  rejectedAt: Date,
  cancelledBy: {
    type: Schema.Types.ObjectId,
    ref: 'User'
  },
  cancelledAt: Date,
  voidedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User'
  },
  voidedAt: Date,
  reason: {
    type: String,
    required: function() {
      return ['rejected', 'cancelled', 'void'].includes(this.status);
    }
  },
  attachments: [{
    type: {
      type: String,
      required: true
    },
    url: {
      type: String,
      required: true
    }
  }],
  isDeleted: {
    type: Boolean,
    default: false
  },
  deletedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User'
  },
  deletedAt: Date
}, {
  timestamps: true
});

// Create indexes for efficient querying
expenseSchema.index({ createdBy: 1 });
expenseSchema.index({ departmentId: 1 });
expenseSchema.index({ status: 1 });
expenseSchema.index({ date: 1 });
expenseSchema.index({ category: 1 });
expenseSchema.index({ isDeleted: 1 });

// Prevent deletion of approved expenses
expenseSchema.pre('remove', function(next) {
  if (this.status === 'approved') {
    throw new Error('Cannot delete approved expenses');
  }
  next();
});

// Soft delete middleware
expenseSchema.pre('find', function() {
  this.where({ isDeleted: false });
});

expenseSchema.pre('findOne', function() {
  this.where({ isDeleted: false });
});

// Method to soft delete an expense
expenseSchema.methods.softDelete = async function(userId: mongoose.Types.ObjectId) {
  this.isDeleted = true;
  this.deletedBy = userId;
  this.deletedAt = new Date();
  return this.save();
};

// Method to restore a soft deleted expense
expenseSchema.methods.restore = async function() {
  this.isDeleted = false;
  this.deletedBy = undefined;
  this.deletedAt = undefined;
  return this.save();
};

export const Expense = mongoose.model<IExpense>('Expense', expenseSchema); 

===== C:\Users\Badr Admin\Desktop\src\modules\accounting\models\invoice.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';

export interface IInvoice extends Document {
  invoiceNumber: string;
  customer: {
    _id: mongoose.Types.ObjectId;
    name: string;
    email: string;
    address: string;
  };
  items: {
    description: string;
    quantity: number;
    unitPrice: number;
    total: number;
  }[];
  subtotal: number;
  tax: number;
  total: number;
  status: 'draft' | 'pending' | 'paid' | 'partially_paid' | 'overdue' | 'cancelled' | 'void' | 'refunded';
  dueDate: Date;
  issuedDate: Date;
  paidDate?: Date;
  paymentMethod?: string;
  notes?: string;
  reason?: string;
  createdAt: Date;
  updatedAt: Date;
}

const invoiceSchema = new Schema({
  invoiceNumber: {
    type: String,
    required: true,
    unique: true,
    trim: true
  },
  customer: {
    _id: {
      type: Schema.Types.ObjectId,
      ref: 'Customer',
      required: true
    },
    name: {
      type: String,
      required: true,
      trim: true
    },
    email: {
      type: String,
      required: true,
      trim: true,
      lowercase: true
    },
    address: {
      type: String,
      required: true,
      trim: true
    }
  },
  items: [{
    description: {
      type: String,
      required: true,
      trim: true
    },
    quantity: {
      type: Number,
      required: true,
      min: [1, 'Quantity must be greater than 0']
    },
    unitPrice: {
      type: Number,
      required: true,
      min: [0, 'Unit price cannot be negative']
    },
    total: {
      type: Number,
      required: true,
      min: [0, 'Total cannot be negative']
    }
  }],
  subtotal: {
    type: Number,
    required: true,
    min: [0, 'Subtotal cannot be negative']
  },
  tax: {
    type: Number,
    required: true,
    min: [0, 'Tax cannot be negative']
  },
  total: {
    type: Number,
    required: true,
    min: [0, 'Total cannot be negative']
  },
  status: {
    type: String,
    enum: ['draft', 'pending', 'paid', 'partially_paid', 'overdue', 'cancelled', 'void', 'refunded'],
    default: 'draft'
  },
  dueDate: {
    type: Date,
    required: true
  },
  issuedDate: {
    type: Date,
    default: Date.now
  },
  paidDate: Date,
  paymentMethod: {
    type: String,
    enum: ['cash', 'credit_card', 'bank_transfer', 'check']
  },
  notes: {
    type: String,
    trim: true
  },
  reason: {
    type: String,
    required: function() {
      return ['cancelled', 'void', 'refunded'].includes(this.status);
    }
  }
}, {
  timestamps: true
});

// Create indexes for efficient querying
invoiceSchema.index({ invoiceNumber: 1 }, { unique: true });
invoiceSchema.index({ 'customer._id': 1 });
invoiceSchema.index({ status: 1 });
invoiceSchema.index({ dueDate: 1 });
invoiceSchema.index({ issuedDate: 1 });

// Pre-save middleware to calculate totals
invoiceSchema.pre('save', function(next) {
  if (this.isModified('items')) {
    this.subtotal = this.items.reduce((sum, item) => sum + item.total, 0);
    this.total = this.subtotal + this.tax;
  }
  next();
});

// Prevent deletion of paid invoices
invoiceSchema.pre('remove', function(next) {
  if (['paid', 'partially_paid'].includes(this.status)) {
    throw new Error('Cannot delete paid or partially paid invoices');
  }
  next();
});

export const Invoice = mongoose.model<IInvoice>('Invoice', invoiceSchema); 

===== C:\Users\Badr Admin\Desktop\src\modules\accounting\models\invoiceAccessToken.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';

export interface IInvoiceAccessToken extends Document {
  invoice: mongoose.Types.ObjectId;
  user: mongoose.Types.ObjectId;
  token: string;
  expiresAt: Date;
  operation: 'payment' | 'cancellation' | 'approval';
  details: {
    amount?: number;
    paymentMethod?: string;
    reason?: string;
  };
  status: 'active' | 'completed' | 'expired' | 'cancelled';
  createdAt: Date;
  updatedAt: Date;
}

const invoiceAccessTokenSchema = new Schema({
  invoice: {
    type: Schema.Types.ObjectId,
    ref: 'Invoice',
    required: true
  },
  user: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  token: {
    type: String,
    required: true,
    unique: true
  },
  expiresAt: {
    type: Date,
    required: true
  },
  operation: {
    type: String,
    enum: ['payment', 'cancellation', 'approval'],
    required: true
  },
  details: {
    amount: Number,
    paymentMethod: String,
    reason: String
  },
  status: {
    type: String,
    enum: ['active', 'completed', 'expired', 'cancelled'],
    default: 'active'
  }
}, {
  timestamps: true
});

// Create indexes for efficient querying
invoiceAccessTokenSchema.index({ invoice: 1, status: 1 });
invoiceAccessTokenSchema.index({ user: 1 });
invoiceAccessTokenSchema.index({ token: 1 }, { unique: true });
invoiceAccessTokenSchema.index({ expiresAt: 1 });

// Generate unique token
invoiceAccessTokenSchema.pre('save', function(next) {
  if (!this.token) {
    this.token = `${this.invoice}-${this.user}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  next();
});

// Check for existing active tokens
invoiceAccessTokenSchema.pre('save', async function(next) {
  if (this.isNew && this.status === 'active') {
    const existingToken = await this.constructor.findOne({
      invoice: this.invoice,
      status: 'active',
      _id: { $ne: this._id }
    });

    if (existingToken) {
      throw new Error('Another user is currently accessing this invoice');
    }
  }
  next();
});

// Auto-expire tokens
invoiceAccessTokenSchema.methods.checkExpiration = async function() {
  if (this.status === 'active' && this.expiresAt < new Date()) {
    this.status = 'expired';
    await this.save();
  }
};

export const InvoiceAccessToken = mongoose.model<IInvoiceAccessToken>('InvoiceAccessToken', invoiceAccessTokenSchema); 

===== C:\Users\Badr Admin\Desktop\src\modules\accounting\routes\expense.routes.ts =====
import { Router } from 'express';
import { ExpenseController } from '../controllers/expense.controller';
import { authenticate } from '../../../shared/middleware/authenticate';
import { authorize } from '../../../shared/middleware/authorize';
import { validateRequest } from '../../../shared/middleware/validateRequest';
import { expenseSchema } from '../schemas/expense.schema';

const router = Router();
const expenseController = new ExpenseController();

// Get all expenses
router.get(
  '/',
  authenticate,
  authorize(['accounting:view']),
  expenseController.getExpenses
);

// Get a single expense
router.get(
  '/:id',
  authenticate,
  authorize(['accounting:view']),
  expenseController.getExpenseById
);

// Create a new expense
router.post(
  '/',
  authenticate,
  authorize(['accounting:create']),
  validateRequest(expenseSchema),
  expenseController.createExpense
);

// Update expense status
router.patch(
  '/:id/status',
  authenticate,
  authorize(['accounting:update']),
  expenseController.updateExpenseStatus
);

// Soft delete an expense
router.patch(
  '/:id/soft-delete',
  authenticate,
  authorize(['accounting:delete']),
  expenseController.softDeleteExpense
);

// Restore a soft deleted expense
router.patch(
  '/:id/restore',
  authenticate,
  authorize(['accounting:restore']),
  expenseController.restoreExpense
);

export default router; 

===== C:\Users\Badr Admin\Desktop\src\modules\accounting\routes\invoice.routes.ts =====
import { Router } from 'express';
import { validateRequest } from '../../../middleware/validateRequest';
import { invoiceAccessTokenSchema } from '../schemas/invoiceAccessToken.schema';
import { 
  requestAccessToken,
  releaseAccessToken,
  cancelAccessToken,
  getActiveAccessToken
} from '../controllers/invoiceAccessToken.controller';
import { protect } from '../../../middleware/auth';

const router = Router();

// Access token routes
router.post(
  '/access-token',
  protect,
  validateRequest(invoiceAccessTokenSchema),
  requestAccessToken
);

router.post(
  '/access-token/:token/release',
  protect,
  releaseAccessToken
);

router.post(
  '/access-token/:token/cancel',
  protect,
  cancelAccessToken
);

router.get(
  '/access-token/:invoice',
  protect,
  getActiveAccessToken
);

// ... existing code ...

export default router; 

===== C:\Users\Badr Admin\Desktop\src\modules\accounting\schemas\invoiceAccessToken.schema.ts =====
import { z } from 'zod';

export const invoiceAccessTokenSchema = z.object({
  invoice: z.string().min(1, 'Invoice ID is required'),
  operation: z.enum(['payment', 'cancellation', 'approval']),
  details: z.object({
    amount: z.number().positive().optional(),
    paymentMethod: z.string().optional(),
    reason: z.string().optional()
  }).refine((data) => {
    if (data.amount !== undefined && data.paymentMethod === undefined) {
      return false;
    }
    return true;
  }, {
    message: 'Payment method is required when amount is provided'
  })
});

export type InvoiceAccessTokenRequest = z.infer<typeof invoiceAccessTokenSchema>; 

===== C:\Users\Badr Admin\Desktop\src\modules\hr\controllers\employeeAccessToken.controller.ts =====
import { Request, Response, NextFunction } from 'express';
import { EmployeeAccessToken } from '../models/employeeAccessToken.model';
import { Employee } from '../models/employee.model';
import { AppError } from '../../../utils/appError';
import { catchAsync } from '../../../utils/catchAsync';

// Request access token
export const requestAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { employee, operation, details } = req.body;

  // Check if employee exists
  const employeeDoc = await Employee.findById(employee);
  if (!employeeDoc) {
    return next(new AppError('Employee not found', 404));
  }

  // Validate operation based on current status
  if (operation === 'status_change') {
    if (!details.newStatus) {
      return next(new AppError('New status is required for status change operation', 400));
    }
    
    // Validate status transition
    if (['terminated', 'retired', 'deceased'].includes(details.newStatus) && !details.reason) {
      return next(new AppError('Reason is required for this status change', 400));
    }
  }

  if (operation === 'asset_assignment' && !details.assetId) {
    return next(new AppError('Asset ID is required for asset assignment operation', 400));
  }

  if (operation === 'leave_approval' && !details.leaveRequestId) {
    return next(new AppError('Leave request ID is required for leave approval operation', 400));
  }

  // Check for existing active tokens
  const existingToken = await EmployeeAccessToken.findOne({
    employee,
    status: 'active'
  });

  if (existingToken) {
    return next(new AppError('Another user is currently accessing this employee', 409));
  }

  // Create new access token
  const token = await EmployeeAccessToken.create({
    employee,
    user: req.user._id,
    operation,
    details,
    expiresAt: new Date(Date.now() + 5 * 60 * 1000) // 5 minutes expiration
  });

  res.status(201).json({
    status: 'success',
    data: {
      token: {
        token: token.token,
        expiresAt: token.expiresAt,
        operation: token.operation,
        details: token.details
      }
    }
  });
});

// Release access token
export const releaseAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { token } = req.params;

  const accessToken = await EmployeeAccessToken.findOne({ token });
  if (!accessToken) {
    return next(new AppError('Access token not found', 404));
  }

  if (accessToken.user.toString() !== req.user._id.toString()) {
    return next(new AppError('Not authorized to release this token', 403));
  }

  accessToken.status = 'completed';
  await accessToken.save();

  res.status(200).json({
    status: 'success',
    data: null
  });
});

// Cancel access token
export const cancelAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { token } = req.params;

  const accessToken = await EmployeeAccessToken.findOne({ token });
  if (!accessToken) {
    return next(new AppError('Access token not found', 404));
  }

  if (accessToken.user.toString() !== req.user._id.toString()) {
    return next(new AppError('Not authorized to cancel this token', 403));
  }

  accessToken.status = 'cancelled';
  await accessToken.save();

  res.status(200).json({
    status: 'success',
    data: null
  });
});

// Get active access token for an employee
export const getActiveAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { employee } = req.params;

  const accessToken = await EmployeeAccessToken.findOne({
    employee,
    status: 'active'
  });

  if (!accessToken) {
    return next(new AppError('No active access token found for this employee', 404));
  }

  res.status(200).json({
    status: 'success',
    data: {
      token: {
        token: accessToken.token,
        expiresAt: accessToken.expiresAt,
        operation: accessToken.operation,
        details: accessToken.details
      }
    }
  });
}); 

===== C:\Users\Badr Admin\Desktop\src\modules\hr\models\employee.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';

export interface IEmployee extends Document {
  firstName: string;
  lastName: string;
  email: string;
  phone: string;
  department: mongoose.Types.ObjectId;
  position: string;
  hireDate: Date;
  salary: number;
  status: 'active' | 'on_leave' | 'suspended' | 'retired' | 'fired' | 'deceased' | 'resigned';
  manager?: mongoose.Types.ObjectId;
  emergencyContact?: {
    name: string;
    relationship: string;
    phone: string;
  };
  documents?: {
    type: string;
    url: string;
    expiryDate?: Date;
  }[];
  reason?: string;
  retirementDate?: Date;
  suspensionStartDate?: Date;
  suspensionEndDate?: Date;
  dateOfDeath?: Date;
  createdAt: Date;
  updatedAt: Date;
}

const employeeSchema = new Schema({
  firstName: {
    type: String,
    required: true,
    trim: true
  },
  lastName: {
    type: String,
    required: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    trim: true,
    lowercase: true,
    match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Please enter a valid email address']
  },
  phone: {
    type: String,
    required: true,
    trim: true
  },
  department: {
    type: Schema.Types.ObjectId,
    ref: 'Department',
    required: true
  },
  position: {
    type: String,
    required: true,
    trim: true
  },
  hireDate: {
    type: Date,
    required: true
  },
  salary: {
    type: Number,
    required: true,
    min: [0, 'Salary cannot be negative']
  },
  status: {
    type: String,
    enum: ['active', 'on_leave', 'suspended', 'retired', 'fired', 'deceased', 'resigned'],
    default: 'active'
  },
  manager: {
    type: Schema.Types.ObjectId,
    ref: 'Employee'
  },
  emergencyContact: {
    name: {
      type: String,
      trim: true
    },
    relationship: {
      type: String,
      trim: true
    },
    phone: {
      type: String,
      trim: true
    }
  },
  documents: [{
    type: {
      type: String,
      required: true
    },
    url: {
      type: String,
      required: true
    },
    expiryDate: Date
  }],
  reason: {
    type: String,
    required: function() {
      return ['suspended', 'retired', 'fired', 'deceased', 'resigned'].includes(this.status);
    }
  },
  retirementDate: {
    type: Date,
    required: function() {
      return this.status === 'retired';
    }
  },
  suspensionStartDate: {
    type: Date,
    required: function() {
      return this.status === 'suspended';
    }
  },
  suspensionEndDate: {
    type: Date,
    required: function() {
      return this.status === 'suspended';
    }
  },
  dateOfDeath: {
    type: Date,
    required: function() {
      return this.status === 'deceased';
    }
  }
}, {
  timestamps: true
});

// Create indexes for efficient querying
employeeSchema.index({ email: 1 }, { unique: true });
employeeSchema.index({ department: 1 });
employeeSchema.index({ status: 1 });
employeeSchema.index({ manager: 1 });
employeeSchema.index({ 'documents.expiryDate': 1 });

// Virtual for full name
employeeSchema.virtual('fullName').get(function() {
  return `${this.firstName} ${this.lastName}`;
});

// Prevent deletion of employees with active status
employeeSchema.pre('remove', function(next) {
  if (this.status === 'active') {
    throw new Error('Cannot delete active employee');
  }
  next();
});

export const Employee = mongoose.model<IEmployee>('Employee', employeeSchema); 

===== C:\Users\Badr Admin\Desktop\src\modules\hr\models\employeeAccessToken.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';

export interface IEmployeeAccessToken extends Document {
  employee: mongoose.Types.ObjectId;
  user: mongoose.Types.ObjectId;
  token: string;
  expiresAt: Date;
  operation: 'status_change' | 'asset_assignment' | 'leave_approval';
  details: {
    newStatus?: string;
    reason?: string;
    assetId?: mongoose.Types.ObjectId;
    leaveRequestId?: mongoose.Types.ObjectId;
  };
  status: 'active' | 'completed' | 'expired' | 'cancelled';
  createdAt: Date;
  updatedAt: Date;
}

const employeeAccessTokenSchema = new Schema({
  employee: {
    type: Schema.Types.ObjectId,
    ref: 'Employee',
    required: true
  },
  user: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  token: {
    type: String,
    required: true,
    unique: true
  },
  expiresAt: {
    type: Date,
    required: true
  },
  operation: {
    type: String,
    enum: ['status_change', 'asset_assignment', 'leave_approval'],
    required: true
  },
  details: {
    newStatus: String,
    reason: String,
    assetId: {
      type: Schema.Types.ObjectId,
      ref: 'Asset'
    },
    leaveRequestId: {
      type: Schema.Types.ObjectId,
      ref: 'LeaveRequest'
    }
  },
  status: {
    type: String,
    enum: ['active', 'completed', 'expired', 'cancelled'],
    default: 'active'
  }
}, {
  timestamps: true
});

// Create indexes for efficient querying
employeeAccessTokenSchema.index({ employee: 1, status: 1 });
employeeAccessTokenSchema.index({ user: 1 });
employeeAccessTokenSchema.index({ token: 1 }, { unique: true });
employeeAccessTokenSchema.index({ expiresAt: 1 });

// Generate unique token
employeeAccessTokenSchema.pre('save', function(next) {
  if (!this.token) {
    this.token = `${this.employee}-${this.user}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  next();
});

// Check for existing active tokens
employeeAccessTokenSchema.pre('save', async function(next) {
  if (this.isNew && this.status === 'active') {
    const existingToken = await this.constructor.findOne({
      employee: this.employee,
      status: 'active',
      _id: { $ne: this._id }
    });

    if (existingToken) {
      throw new Error('Another user is currently accessing this employee');
    }
  }
  next();
});

// Auto-expire tokens
employeeAccessTokenSchema.methods.checkExpiration = async function() {
  if (this.status === 'active' && this.expiresAt < new Date()) {
    this.status = 'expired';
    await this.save();
  }
};

export const EmployeeAccessToken = mongoose.model<IEmployeeAccessToken>('EmployeeAccessToken', employeeAccessTokenSchema); 

===== C:\Users\Badr Admin\Desktop\src\modules\hr\schemas\employeeAccessToken.schema.ts =====
import { z } from 'zod';

export const employeeAccessTokenSchema = z.object({
  employee: z.string().min(1, 'Employee ID is required'),
  operation: z.enum(['status_change', 'asset_assignment', 'leave_approval']),
  details: z.object({
    newStatus: z.string().optional(),
    reason: z.string().optional(),
    assetId: z.string().optional(),
    leaveRequestId: z.string().optional()
  })
});

export type EmployeeAccessTokenRequest = z.infer<typeof employeeAccessTokenSchema>; 

===== C:\Users\Badr Admin\Desktop\src\modules\shared\middleware\roleAuth.ts =====
import { Request, Response, NextFunction } from 'express';
import { UserRole } from '../../../models/user.model';
import { typedLogger } from '../../../utils/logger';

// Define role hierarchies
const roleHierarchy: Record<UserRole, UserRole[]> = {
  superadmin: ['admin', 'manager', 'seller', 'stock_clerk', 'hr_manager', 'accountant', 'stock_manager', 'employee', 'finance_manager'],
  admin: ['manager', 'seller', 'stock_clerk', 'hr_manager', 'accountant', 'stock_manager', 'employee', 'finance_manager'],
  manager: ['seller', 'stock_clerk', 'employee'],
  hr_manager: ['employee'],
  accountant: [],
  stock_manager: ['stock_clerk'],
  finance_manager: ['accountant'],
  seller: [],
  stock_clerk: [],
  employee: [],
};

// Define module-specific permissions
const modulePermissions: Record<string, string[]> = {
  hr: ['hr:create', 'hr:read', 'hr:update', 'hr:delete'],
  stock: ['stock:create', 'stock:read', 'stock:update', 'stock:delete'],
  accounting: ['accounting:create', 'accounting:read', 'accounting:update', 'accounting:delete'],
  finance: ['finance:create', 'finance:read', 'finance:update', 'finance:delete'],
};

// Helper function to check if a role has access to another role
const hasRoleAccess = (userRole: UserRole, targetRole: UserRole): boolean => {
  if (userRole === targetRole) return true;
  return roleHierarchy[userRole]?.includes(targetRole) || false;
};

// Helper function to check if a role has access to a module
const hasModuleAccess = (userRole: UserRole, module: string): boolean => {
  const modulePerms = modulePermissions[module];
  if (!modulePerms) return false;

  switch (userRole) {
    case 'superadmin':
    case 'admin':
      return true;
    case 'hr_manager':
      return module === 'hr';
    case 'accountant':
      return module === 'accounting';
    case 'stock_manager':
      return module === 'stock';
    case 'finance_manager':
      return module === 'finance';
    default:
      return false;
  }
};

// Middleware to check role access
export const checkRole = (allowedRoles: UserRole[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      const userRole = req.user?.role as UserRole;
      
      if (!userRole) {
        typedLogger.warn('No user role found in request');
        return res.status(401).json({ message: 'Unauthorized' });
      }

      const hasAccess = allowedRoles.some(role => hasRoleAccess(userRole, role));
      
      if (!hasAccess) {
        typedLogger.warn('User does not have required role access', {
          userRole,
          requiredRoles: allowedRoles,
        });
        return res.status(403).json({ message: 'Forbidden: Insufficient role permissions' });
      }

      next();
    } catch (error) {
      typedLogger.error('Error in role check middleware:', { error });
      return res.status(500).json({ message: 'Internal server error' });
    }
  };
};

// Middleware to check module access
export const checkModuleAccess = (module: string) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      const userRole = req.user?.role as UserRole;
      
      if (!userRole) {
        typedLogger.warn('No user role found in request');
        return res.status(401).json({ message: 'Unauthorized' });
      }

      const hasAccess = hasModuleAccess(userRole, module);
      
      if (!hasAccess) {
        typedLogger.warn('User does not have access to module', {
          userRole,
          module,
        });
        return res.status(403).json({ message: 'Forbidden: Insufficient module access' });
      }

      next();
    } catch (error) {
      typedLogger.error('Error in module access check middleware:', { error });
      return res.status(500).json({ message: 'Internal server error' });
    }
  };
};

// Middleware to check specific permission
export const checkPermission = (permission: string) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      const userPermissions = req.user?.permissions as string[];
      
      if (!userPermissions) {
        typedLogger.warn('No user permissions found in request');
        return res.status(401).json({ message: 'Unauthorized' });
      }

      const hasAccess = userPermissions.includes(permission);
      
      if (!hasAccess) {
        typedLogger.warn('User does not have required permission', {
          userPermissions,
          requiredPermission: permission,
        });
        return res.status(403).json({ message: 'Forbidden: Insufficient permissions' });
      }

      next();
    } catch (error) {
      typedLogger.error('Error in permission check middleware:', { error });
      return res.status(500).json({ message: 'Internal server error' });
    }
  };
}; 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\controllers\purchaseOrder.controller.ts =====
import { Request, Response, NextFunction } from 'express';
import { PurchaseOrder } from '../models/purchaseOrder.model';
import { InventoryItem } from '../models/inventory.model';
import { StockMovement } from '../models/stockMovement.model';
import { PurchaseOrderAccessToken } from '../models/purchaseOrderAccessToken.model';
import { AppError } from '../../../utils/appError';
import { catchAsync } from '../../../utils/catchAsync';
import mongoose from 'mongoose';

// Get all purchase orders with filters
export const getAllPurchaseOrders = catchAsync(async (req: Request, res: Response) => {
  const query: any = {};

  // Apply filters
  if (req.query.status) query.status = req.query.status;
  if (req.query.supplier) query.supplier = req.query.supplier;
  if (req.query.startDate && req.query.endDate) {
    query.createdAt = {
      $gte: new Date(req.query.startDate as string),
      $lte: new Date(req.query.endDate as string),
    };
  }

  const purchaseOrders = await PurchaseOrder.find(query)
    .populate('supplier', 'name')
    .populate('items.product', 'name sku')
    .sort({ createdAt: -1 });

  res.status(200).json({
    status: 'success',
    data: purchaseOrders,
  });
});

// Get single purchase order
export const getPurchaseOrder = catchAsync(async (req: Request, res: Response) => {
  const purchaseOrder = await PurchaseOrder.findById(req.params.id)
    .populate('supplier', 'name')
    .populate('items.product', 'name sku');
  
  if (!purchaseOrder) {
    throw new AppError(404, 'Purchase order not found');
  }

  res.status(200).json({
    status: 'success',
    data: purchaseOrder,
  });
});

// Create purchase order
export const createPurchaseOrder = catchAsync(async (req: Request, res: Response) => {
  const { items, supplier, expectedDeliveryDate } = req.body;

  // Validate items
  if (!items || !Array.isArray(items) || items.length === 0) {
    throw new AppError(400, 'Purchase order must have at least one item');
  }

  // Check for duplicate products
  const productIds = items.map(item => item.product.toString());
  if (new Set(productIds).size !== productIds.length) {
    throw new AppError(400, 'Duplicate products are not allowed in the same order');
  }

  // Validate expected delivery date
  if (expectedDeliveryDate && new Date(expectedDeliveryDate) <= new Date()) {
    throw new AppError(400, 'Expected delivery date must be in the future');
  }

  // Calculate total
  const total = items.reduce((sum, item) => sum + (item.quantity * item.price), 0);

  const purchaseOrder = await PurchaseOrder.create({
    ...req.body,
    total,
    status: 'pending',
  });
  
  res.status(201).json({
    status: 'success',
    data: purchaseOrder,
  });
});

// Update purchase order
export const updatePurchaseOrder = catchAsync(async (req: Request, res: Response) => {
  const purchaseOrder = await PurchaseOrder.findById(req.params.id);

  if (!purchaseOrder) {
    throw new AppError(404, 'Purchase order not found');
  }

  // Don't allow updating items or total after creation
  if (req.body.items || req.body.total) {
    throw new AppError(400, 'Cannot update items or total of existing purchase order');
  }

  // Don't allow updating status through this endpoint
  if (req.body.status) {
    throw new AppError(400, 'Please use the status update endpoint to change status');
  }

  const updatedPurchaseOrder = await PurchaseOrder.findByIdAndUpdate(
    req.params.id,
    req.body,
    {
      new: true,
      runValidators: true,
    }
  );

  res.status(200).json({
    status: 'success',
    data: updatedPurchaseOrder,
  });
});

// Update purchase order status
export const updatePurchaseOrderStatus = catchAsync(async (req: Request, res: Response) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const { status, receivedItems, accessToken } = req.body;
    const purchaseOrder = await PurchaseOrder.findById(req.params.id)
      .populate('items.product');

    if (!purchaseOrder) {
      throw new AppError(404, 'Purchase order not found');
    }

    // Validate access token for operations that require exclusive access
    if (['received', 'cancelled'].includes(status)) {
      if (!accessToken) {
        throw new AppError(400, 'Access token is required for this operation');
      }

      const token = await PurchaseOrderAccessToken.findOne({
        token: accessToken,
        purchaseOrder: purchaseOrder._id,
        status: 'active'
      });

      if (!token) {
        throw new AppError(400, 'Invalid or expired access token');
      }

      if (token.user.toString() !== req.user._id.toString()) {
        throw new AppError(403, 'Not authorized to perform this operation');
      }

      if (token.operation !== (status === 'received' ? 'receive' : 'cancel')) {
        throw new AppError(400, 'Access token operation does not match requested operation');
      }
    }

    // Handle status transition
    if (status === 'received' && purchaseOrder.status !== 'approved') {
      throw new AppError(400, 'Purchase order must be approved before receiving');
    }

    // If receiving the order, update inventory
    if (status === 'received' && purchaseOrder.status !== 'received') {
      const itemsToProcess = receivedItems || purchaseOrder.items;

      for (const item of itemsToProcess) {
        const orderItem = purchaseOrder.items.find(
          oi => oi.product.toString() === item.product.toString()
        );

        if (!orderItem) {
          throw new AppError(400, `Product ${item.product} not found in order`);
        }

        const product = item.product as any;
        const quantity = item.quantity || orderItem.quantity;
        
        // Validate quantity
        if (quantity <= 0) {
          throw new AppError(400, 'Received quantity must be greater than 0');
        }
        if (quantity > orderItem.quantity) {
          throw new AppError(400, 'Received quantity cannot exceed ordered quantity');
        }

        // Update inventory quantity
        await InventoryItem.findByIdAndUpdate(
          product._id,
          { $inc: { quantity: quantity } },
          { session }
        );

        // Create stock movement
        await StockMovement.create([{
          inventoryItem: product._id,
          quantity,
          type: 'in',
          source: purchaseOrder.supplier.toString(),
          reference: `PO-${purchaseOrder._id}`,
          user: req.user?._id,
          notes: `Received from PO ${purchaseOrder._id}`,
        }], { session });
      }

      // Update order status
      purchaseOrder.status = 'received';
      purchaseOrder.receivedAt = new Date();
      await purchaseOrder.save({ session });

      // Complete the access token
      if (accessToken) {
        await PurchaseOrderAccessToken.findOneAndUpdate(
          { token: accessToken },
          { status: 'completed' },
          { session }
        );
      }
    } else {
      purchaseOrder.status = status;
      await purchaseOrder.save({ session });

      // Complete the access token for cancellation
      if (status === 'cancelled' && accessToken) {
        await PurchaseOrderAccessToken.findOneAndUpdate(
          { token: accessToken },
          { status: 'completed' },
          { session }
        );
      }
    }

    await session.commitTransaction();

    res.status(200).json({
      status: 'success',
      data: purchaseOrder,
    });
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
});

// Delete purchase order
export const deletePurchaseOrder = catchAsync(async (req: Request, res: Response) => {
  const purchaseOrder = await PurchaseOrder.findById(req.params.id);

  if (!purchaseOrder) {
    throw new AppError(404, 'Purchase order not found');
  }

  // Don't allow deleting received orders
  if (purchaseOrder.status === 'received') {
    throw new AppError(400, 'Cannot delete received purchase order');
  }

  await purchaseOrder.deleteOne();

  res.status(204).json({
    status: 'success',
    data: null,
  });
}); 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\controllers\purchaseOrderAccessToken.controller.ts =====
import { Request, Response, NextFunction } from 'express';
import { PurchaseOrderAccessToken } from '../models/purchaseOrderAccessToken.model';
import { PurchaseOrder } from '../models/purchaseOrder.model';
import { AppError } from '../../../utils/appError';
import { catchAsync } from '../../../utils/catchAsync';

// Request access token
export const requestAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { purchaseOrder, operation, items } = req.body;

  // Check if purchase order exists and is in correct status
  const order = await PurchaseOrder.findById(purchaseOrder);
  if (!order) {
    return next(new AppError('Purchase order not found', 404));
  }

  // Validate operation based on current status
  if (operation === 'receive' && order.status !== 'approved') {
    return next(new AppError('Purchase order must be approved before receiving', 400));
  }

  if (operation === 'approve' && order.status !== 'pending') {
    return next(new AppError('Purchase order must be pending before approval', 400));
  }

  if (operation === 'cancel' && ['completed', 'cancelled'].includes(order.status)) {
    return next(new AppError('Cannot cancel a completed or already cancelled order', 400));
  }

  // Validate items if provided
  if (items && items.length > 0) {
    for (const item of items) {
      const orderItem = order.items.find(oi => oi.product.toString() === item.product.toString());
      if (!orderItem) {
        return next(new AppError(`Product ${item.product} not found in order`, 400));
      }
      if (item.quantity > orderItem.quantity) {
        return next(new AppError(`Received quantity cannot exceed ordered quantity for product ${item.product}`, 400));
      }
    }
  }

  // Check for existing active tokens
  const existingToken = await PurchaseOrderAccessToken.findOne({
    purchaseOrder,
    status: 'active'
  });

  if (existingToken) {
    return next(new AppError('Another user is currently accessing this purchase order', 409));
  }

  // Create new access token
  const token = await PurchaseOrderAccessToken.create({
    purchaseOrder,
    user: req.user._id,
    operation,
    items: items || [],
    expiresAt: new Date(Date.now() + 5 * 60 * 1000) // 5 minutes expiration
  });

  res.status(201).json({
    status: 'success',
    data: {
      token: {
        token: token.token,
        expiresAt: token.expiresAt,
        operation: token.operation,
        items: token.items
      }
    }
  });
});

// Release access token
export const releaseAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { token } = req.params;

  const accessToken = await PurchaseOrderAccessToken.findOne({ token });
  if (!accessToken) {
    return next(new AppError('Access token not found', 404));
  }

  if (accessToken.user.toString() !== req.user._id.toString()) {
    return next(new AppError('Not authorized to release this token', 403));
  }

  accessToken.status = 'completed';
  await accessToken.save();

  res.status(200).json({
    status: 'success',
    data: null
  });
});

// Cancel access token
export const cancelAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { token } = req.params;

  const accessToken = await PurchaseOrderAccessToken.findOne({ token });
  if (!accessToken) {
    return next(new AppError('Access token not found', 404));
  }

  if (accessToken.user.toString() !== req.user._id.toString()) {
    return next(new AppError('Not authorized to cancel this token', 403));
  }

  accessToken.status = 'cancelled';
  await accessToken.save();

  res.status(200).json({
    status: 'success',
    data: null
  });
});

// Get active access token for a purchase order
export const getActiveAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { purchaseOrder } = req.params;

  const accessToken = await PurchaseOrderAccessToken.findOne({
    purchaseOrder,
    status: 'active'
  });

  if (!accessToken) {
    return next(new AppError('No active access token found for this purchase order', 404));
  }

  res.status(200).json({
    status: 'success',
    data: {
      token: {
        token: accessToken.token,
        expiresAt: accessToken.expiresAt,
        operation: accessToken.operation,
        items: accessToken.items
      }
    }
  });
}); 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\controllers\stockAccessToken.controller.ts =====
import { Request, Response, NextFunction } from 'express';
import { StockAccessToken } from '../models/stockAccessToken.model';
import { InventoryItem } from '../models/inventory.model';
import { AppError } from '../../../utils/appError';
import { catchAsync } from '../../../utils/catchAsync';

// Request access token
export const requestAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { inventoryItem, operation, quantity, details } = req.body;

  // Check if inventory item exists
  const item = await InventoryItem.findById(inventoryItem);
  if (!item) {
    return next(new AppError('Inventory item not found', 404));
  }

  // Validate operation based on current status
  if (operation === 'sale') {
    // Check if item is active
    if (item.status !== 'active') {
      return next(new AppError('Item is not available for sale', 400));
    }
    
    // Check if sufficient stock is available
    if (item.quantity < quantity) {
      return next(new AppError('Insufficient stock available', 400));
    }
  }

  if (operation === 'transfer') {
    if (!details?.destination) {
      return next(new AppError('Destination is required for transfer operation', 400));
    }
    
    // Check if sufficient stock is available
    if (item.quantity < quantity) {
      return next(new AppError('Insufficient stock available', 400));
    }
  }

  if (operation === 'adjustment') {
    if (!details?.reason) {
      return next(new AppError('Reason is required for adjustment operation', 400));
    }
  }

  // Check for existing active tokens
  const existingToken = await StockAccessToken.findOne({
    inventoryItem,
    status: 'active'
  });

  if (existingToken) {
    return next(new AppError('Another user is currently accessing this inventory item', 409));
  }

  // Create new access token
  const token = await StockAccessToken.create({
    inventoryItem,
    user: req.user._id,
    operation,
    quantity,
    details,
    expiresAt: new Date(Date.now() + 5 * 60 * 1000) // 5 minutes expiration
  });

  res.status(201).json({
    status: 'success',
    data: {
      token: {
        token: token.token,
        expiresAt: token.expiresAt,
        operation: token.operation,
        quantity: token.quantity,
        details: token.details
      }
    }
  });
});

// Release access token
export const releaseAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { token } = req.params;

  const accessToken = await StockAccessToken.findOne({ token });
  if (!accessToken) {
    return next(new AppError('Access token not found', 404));
  }

  if (accessToken.user.toString() !== req.user._id.toString()) {
    return next(new AppError('Not authorized to release this token', 403));
  }

  accessToken.status = 'completed';
  await accessToken.save();

  res.status(200).json({
    status: 'success',
    data: null
  });
});

// Cancel access token
export const cancelAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { token } = req.params;

  const accessToken = await StockAccessToken.findOne({ token });
  if (!accessToken) {
    return next(new AppError('Access token not found', 404));
  }

  if (accessToken.user.toString() !== req.user._id.toString()) {
    return next(new AppError('Not authorized to cancel this token', 403));
  }

  accessToken.status = 'cancelled';
  await accessToken.save();

  res.status(200).json({
    status: 'success',
    data: null
  });
});

// Get active access token for an inventory item
export const getActiveAccessToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {
  const { inventoryItem } = req.params;

  const accessToken = await StockAccessToken.findOne({
    inventoryItem,
    status: 'active'
  });

  if (!accessToken) {
    return next(new AppError('No active access token found for this inventory item', 404));
  }

  res.status(200).json({
    status: 'success',
    data: {
      token: {
        token: accessToken.token,
        expiresAt: accessToken.expiresAt,
        operation: accessToken.operation,
        quantity: accessToken.quantity,
        details: accessToken.details
      }
    }
  });
}); 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\controllers\stockCategory.controller.ts =====
import { Request, Response } from 'express';
import { StockCategory } from '../models/stockCategory.model';
import { AppError } from '../../../utils/appError';
import { catchAsync } from '../../../utils/catchAsync';

// Get all categories
export const getAllCategories = catchAsync(async (req: Request, res: Response) => {
  const categories = await StockCategory.find().sort({ name: 1 });
  res.status(200).json({
    status: 'success',
    data: categories,
  });
});

// Get single category
export const getCategory = catchAsync(async (req: Request, res: Response) => {
  const category = await StockCategory.findById(req.params.id);
  
  if (!category) {
    throw new AppError(404, 'Category not found');
  }

  res.status(200).json({
    status: 'success',
    data: category,
  });
});

// Create category
export const createCategory = catchAsync(async (req: Request, res: Response) => {
  const category = await StockCategory.create(req.body);
  
  res.status(201).json({
    status: 'success',
    data: category,
  });
});

// Update category
export const updateCategory = catchAsync(async (req: Request, res: Response) => {
  const category = await StockCategory.findByIdAndUpdate(
    req.params.id,
    req.body,
    {
      new: true,
      runValidators: true,
    }
  );

  if (!category) {
    throw new AppError(404, 'Category not found');
  }

  res.status(200).json({
    status: 'success',
    data: category,
  });
});

// Delete category
export const deleteCategory = catchAsync(async (req: Request, res: Response) => {
  const category = await StockCategory.findByIdAndDelete(req.params.id);

  if (!category) {
    throw new AppError(404, 'Category not found');
  }

  res.status(204).json({
    status: 'success',
    data: null,
  });
}); 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\controllers\stockMovement.controller.ts =====
import { Request, Response } from 'express';
import { StockMovement } from '../models/stockMovement.model';
import { InventoryItem } from '../models/inventory.model';
import { StockAccessToken } from '../models/stockAccessToken.model';
import { AppError } from '../../../utils/appError';
import { catchAsync } from '../../../utils/catchAsync';
import mongoose from 'mongoose';

// Get all movements with filters
export const getAllMovements = catchAsync(async (req: Request, res: Response) => {
  const query: any = {};

  // Apply filters
  if (req.query.type) query.type = req.query.type;
  if (req.query.status) query.status = req.query.status;
  if (req.query.inventoryItem) query.inventoryItem = req.query.inventoryItem;
  if (req.query.startDate && req.query.endDate) {
    query.timestamp = {
      $gte: new Date(req.query.startDate as string),
      $lte: new Date(req.query.endDate as string),
    };
  }

  // Apply pagination
  const page = parseInt(req.query.page as string) || 1;
  const limit = parseInt(req.query.limit as string) || 10;
  const skip = (page - 1) * limit;

  const [movements, total] = await Promise.all([
    StockMovement.find(query)
      .populate('inventoryItem', 'name sku')
      .populate('user', 'name email')
      .sort({ timestamp: -1 })
      .skip(skip)
      .limit(limit),
    StockMovement.countDocuments(query),
  ]);

  res.status(200).json({
    status: 'success',
    data: movements,
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit),
    },
  });
});

// Get single movement
export const getMovement = catchAsync(async (req: Request, res: Response) => {
  const movement = await StockMovement.findById(req.params.id)
    .populate('inventoryItem', 'name sku')
    .populate('user', 'name email');
  
  if (!movement) {
    throw new AppError(404, 'Stock movement not found');
  }

  res.status(200).json({
    status: 'success',
    data: movement,
  });
});

// Create movement
export const createMovement = catchAsync(async (req: Request, res: Response) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const { inventoryItem, quantity, type, source, destination, notes, timestamp, accessToken } = req.body;

    // Validate quantity
    if (quantity <= 0) {
      throw new AppError(400, 'Quantity must be greater than 0');
    }

    // Validate source/destination for transfer
    if (type === 'transfer') {
      if (!source || !destination) {
        throw new AppError(400, 'Source and destination are required for transfers');
      }
      if (source === destination) {
        throw new AppError(400, 'Source and destination cannot be the same');
      }
    }

    // Check inventory item exists
    const item = await InventoryItem.findById(inventoryItem);
    if (!item) {
      throw new AppError(404, 'Inventory item not found');
    }

    // For outgoing movements, validate access token
    if (type === 'out') {
      if (!accessToken) {
        throw new AppError(400, 'Access token is required for outgoing movements');
      }

      const token = await StockAccessToken.findOne({ 
        token: accessToken,
        status: 'active',
        inventoryItem,
        operation: 'sale'
      });

      if (!token) {
        throw new AppError(400, 'Invalid or expired access token');
      }

      if (token.user.toString() !== req.user?._id.toString()) {
        throw new AppError(403, 'Not authorized to use this access token');
      }

      if (token.quantity !== quantity) {
        throw new AppError(400, 'Token quantity does not match movement quantity');
      }

      // Check sufficient stock for outgoing movements
      if (item.quantity < quantity) {
        throw new AppError(400, 'Insufficient stock available');
      }
    }

    // Create movement
    const movement = await StockMovement.create([{
      inventoryItem,
      quantity,
      type,
      source,
      destination,
      timestamp: timestamp ? new Date(timestamp) : new Date(),
      user: req.user?._id,
      notes,
      status: 'pending',
    }], { session });

    // Update inventory
    const quantityChange = type === 'in' ? quantity : -quantity;
    await InventoryItem.findByIdAndUpdate(
      inventoryItem,
      { $inc: { quantity: quantityChange } },
      { session }
    );

    // Complete the movement
    movement[0].status = 'completed';
    await movement[0].save({ session });

    // If this was an outgoing movement, complete the access token
    if (type === 'out' && accessToken) {
      await StockAccessToken.findOneAndUpdate(
        { token: accessToken },
        { status: 'completed' },
        { session }
      );
    }

    await session.commitTransaction();

    res.status(201).json({
      status: 'success',
      data: movement[0],
    });
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
});

// Update movement
export const updateMovement = catchAsync(async (req: Request, res: Response) => {
  const movement = await StockMovement.findById(req.params.id);

  if (!movement) {
    throw new AppError(404, 'Stock movement not found');
  }

  // Don't allow updating completed movements
  if (movement.status === 'completed') {
    throw new AppError(400, 'Cannot update completed movements');
  }

  // Don't allow updating quantity or type after creation
  if (req.body.quantity || req.body.type) {
    throw new AppError(400, 'Cannot update quantity or type of existing movement');
  }

  const updatedMovement = await StockMovement.findByIdAndUpdate(
    req.params.id,
    req.body,
    {
      new: true,
      runValidators: true,
    }
  );

  res.status(200).json({
    status: 'success',
    data: updatedMovement,
  });
});

// Cancel movement
export const cancelMovement = catchAsync(async (req: Request, res: Response) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const movement = await StockMovement.findById(req.params.id);

    if (!movement) {
      throw new AppError(404, 'Stock movement not found');
    }

    // Don't allow cancelling completed movements
    if (movement.status === 'completed') {
      throw new AppError(400, 'Cannot cancel completed movements');
    }

    // Reverse the inventory update if movement was pending
    if (movement.status === 'pending') {
      const quantityChange = movement.type === 'in' ? -movement.quantity : movement.quantity;
      await InventoryItem.findByIdAndUpdate(
        movement.inventoryItem,
        { $inc: { quantity: quantityChange } },
        { session }
      );
    }

    movement.status = 'cancelled';
    await movement.save({ session });

    await session.commitTransaction();

    res.status(200).json({
      status: 'success',
      data: movement,
    });
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
});

// Delete movement
export const deleteMovement = catchAsync(async (req: Request, res: Response) => {
  const movement = await StockMovement.findById(req.params.id);

  if (!movement) {
    throw new AppError(404, 'Stock movement not found');
  }

  // Don't allow deleting completed movements
  if (movement.status === 'completed') {
    throw new AppError(400, 'Cannot delete completed movements');
  }

  await movement.deleteOne();

  res.status(204).json({
    status: 'success',
    data: null,
  });
}); 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\controllers\supplier.controller.ts =====
import { Request, Response } from 'express';
import { Supplier } from '../models/supplier.model';
import { AppError } from '../../../utils/appError';
import { catchAsync } from '../../../utils/catchAsync';

// Get all suppliers
export const getAllSuppliers = catchAsync(async (req: Request, res: Response) => {
  const suppliers = await Supplier.find().sort({ name: 1 });
  res.status(200).json({
    status: 'success',
    data: suppliers,
  });
});

// Get single supplier
export const getSupplier = catchAsync(async (req: Request, res: Response) => {
  const supplier = await Supplier.findById(req.params.id);
  
  if (!supplier) {
    throw new AppError(404, 'Supplier not found');
  }

  res.status(200).json({
    status: 'success',
    data: supplier,
  });
});

// Create supplier
export const createSupplier = catchAsync(async (req: Request, res: Response) => {
  const supplier = await Supplier.create(req.body);
  
  res.status(201).json({
    status: 'success',
    data: supplier,
  });
});

// Update supplier
export const updateSupplier = catchAsync(async (req: Request, res: Response) => {
  const supplier = await Supplier.findByIdAndUpdate(
    req.params.id,
    req.body,
    {
      new: true,
      runValidators: true,
    }
  );

  if (!supplier) {
    throw new AppError(404, 'Supplier not found');
  }

  res.status(200).json({
    status: 'success',
    data: supplier,
  });
});

// Delete supplier
export const deleteSupplier = catchAsync(async (req: Request, res: Response) => {
  const supplier = await Supplier.findByIdAndDelete(req.params.id);

  if (!supplier) {
    throw new AppError(404, 'Supplier not found');
  }

  res.status(204).json({
    status: 'success',
    data: null,
  });
});

// Toggle supplier active status
export const toggleSupplierStatus = catchAsync(async (req: Request, res: Response) => {
  const supplier = await Supplier.findById(req.params.id);

  if (!supplier) {
    throw new AppError(404, 'Supplier not found');
  }

  supplier.isActive = !supplier.isActive;
  await supplier.save();

  res.status(200).json({
    status: 'success',
    data: supplier,
  });
}); 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\models\inventory.model.ts =====
import mongoose, { Schema, Document, Types } from 'mongoose';
import { IStockCategory } from './stockCategory.model';
import { ISupplier } from './supplier.model';

export interface IInventoryItem extends Document {
  name: string;
  sku: string;
  description?: string;
  quantity: number;
  unitPrice: number;
  category: Types.ObjectId | IStockCategory;
  supplier: Types.ObjectId | ISupplier;
  minStockLevel: number;
  valuationMethod: 'FIFO' | 'LIFO' | 'AVERAGE';
  status: 'active' | 'discontinued' | 'damaged' | 'lost' | 'stolen' | 'expired' | 'recalled';
  location?: Types.ObjectId;
  lastRestocked?: Date;
  reason?: string;
  createdAt: Date;
  updatedAt: Date;
  stockValue: number;
  stockStatus: 'low' | 'normal' | 'excess';
}

const inventorySchema = new Schema<IInventoryItem>(
  {
    name: {
      type: String,
      required: [true, 'Name is required'],
      trim: true,
      minlength: [2, 'Name must be at least 2 characters long'],
      maxlength: [100, 'Name cannot exceed 100 characters'],
    },
    sku: {
      type: String,
      required: [true, 'SKU is required'],
      unique: true,
      trim: true,
      uppercase: true,
      match: [/^[A-Z0-9-]+$/, 'SKU can only contain uppercase letters, numbers, and hyphens'],
    },
    description: {
      type: String,
      trim: true,
      maxlength: [500, 'Description cannot exceed 500 characters'],
    },
    quantity: {
      type: Number,
      required: [true, 'Quantity is required'],
      min: [0, 'Quantity cannot be negative'],
      default: 0,
      validate: {
        validator: Number.isInteger,
        message: 'Quantity must be a whole number',
      },
    },
    unitPrice: {
      type: Number,
      required: [true, 'Unit price is required'],
      min: [0, 'Unit price cannot be negative'],
      validate: {
        validator: (value: number) => value.toFixed(2) === value.toString(),
        message: 'Unit price must have at most 2 decimal places',
      },
    },
    category: {
      type: Schema.Types.ObjectId,
      ref: 'StockCategory',
      required: [true, 'Category is required'],
    },
    supplier: {
      type: Schema.Types.ObjectId,
      ref: 'Supplier',
      required: [true, 'Supplier is required'],
    },
    minStockLevel: {
      type: Number,
      required: [true, 'Minimum stock level is required'],
      min: [0, 'Minimum stock level cannot be negative'],
      default: 0,
      validate: {
        validator: Number.isInteger,
        message: 'Minimum stock level must be a whole number',
      },
    },
    valuationMethod: {
      type: String,
      enum: {
        values: ['FIFO', 'LIFO', 'AVERAGE'],
        message: '{VALUE} is not a valid valuation method',
      },
      default: 'FIFO',
    },
    status: {
      type: String,
      enum: {
        values: ['active', 'discontinued', 'damaged', 'lost', 'stolen', 'expired', 'recalled'],
        message: '{VALUE} is not a valid status',
      },
      default: 'active',
    },
    location: {
      type: Schema.Types.ObjectId,
      ref: 'Location',
    },
    lastRestocked: {
      type: Date,
      validate: {
        validator: (value: Date) => value <= new Date(),
        message: 'Last restocked date cannot be in the future',
      },
    },
    reason: {
      type: String,
      required: function() {
        return ['discontinued', 'damaged', 'lost', 'stolen', 'expired', 'recalled'].includes(this.status);
      }
    }
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Indexes
inventorySchema.index({ sku: 1 }, { unique: true });
inventorySchema.index({ name: 1 });
inventorySchema.index({ category: 1 });
inventorySchema.index({ supplier: 1 });
inventorySchema.index({ status: 1 });
inventorySchema.index({ location: 1 });

// Virtual for stock value
inventorySchema.virtual('stockValue').get(function() {
  return this.quantity * this.unitPrice;
});

// Virtual for stock status
inventorySchema.virtual('stockStatus').get(function() {
  if (this.quantity <= this.minStockLevel) {
    return 'low';
  } else if (this.quantity > this.minStockLevel * 2) {
    return 'excess';
  }
  return 'normal';
});

// Pre-save middleware
inventorySchema.pre('save', function(next) {
  // Ensure SKU is uppercase
  if (this.isModified('sku')) {
    this.sku = this.sku.toUpperCase();
  }
  
  // Update lastRestocked if quantity increases
  if (this.isModified('quantity') && this.quantity > this.get('quantity')) {
    this.lastRestocked = new Date();
  }
  
  if (this.quantity <= this.minStockLevel) {
    // Emit event for low stock notification
    this.constructor.emit('lowStock', {
      itemId: this._id,
      currentQuantity: this.quantity,
      minStockLevel: this.minStockLevel
    });
  }
  
  next();
});

// Pre-remove middleware
inventorySchema.pre('remove', async function(next) {
  // Check if item is being used in any purchase orders
  const PurchaseOrder = mongoose.model('PurchaseOrder');
  const hasPurchaseOrders = await PurchaseOrder.exists({ 'items.product': this._id });
  
  if (hasPurchaseOrders) {
    next(new Error('Cannot delete item that is referenced in purchase orders'));
  }
  
  if (this.quantity > 0) {
    throw new Error('Cannot delete inventory item with remaining quantity');
  }
  
  next();
});

export const InventoryItem = mongoose.model<IInventoryItem>('InventoryItem', inventorySchema); 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\models\purchaseOrder.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';
import { ISupplier } from './supplier.model';
import { IInventoryItem } from '../../../models/inventory.model';

export interface IPurchaseOrderItem {
  product: IInventoryItem['_id'];
  quantity: number;
  price: number;
  total: number;
}

export interface IPurchaseOrder extends Document {
  supplier: ISupplier['_id'];
  items: IPurchaseOrderItem[];
  status: 'draft' | 'pending' | 'approved' | 'received' | 'cancelled';
  total: number;
  notes?: string;
  expectedDeliveryDate?: Date;
  createdAt: Date;
  updatedAt: Date;
}

const purchaseOrderItemSchema = new Schema<IPurchaseOrderItem>({
  product: {
    type: Schema.Types.ObjectId,
    ref: 'InventoryItem',
    required: [true, 'Product is required'],
  },
  quantity: {
    type: Number,
    required: [true, 'Quantity is required'],
    min: [1, 'Quantity must be greater than 0'],
  },
  price: {
    type: Number,
    required: [true, 'Price is required'],
    min: [0, 'Price must be greater than or equal to 0'],
  },
  total: {
    type: Number,
    required: [true, 'Total is required'],
    min: [0, 'Total must be greater than or equal to 0'],
  },
});

const purchaseOrderSchema = new Schema<IPurchaseOrder>(
  {
    supplier: {
      type: Schema.Types.ObjectId,
      ref: 'Supplier',
      required: [true, 'Supplier is required'],
    },
    items: [purchaseOrderItemSchema],
    status: {
      type: String,
      enum: ['draft', 'pending', 'approved', 'received', 'cancelled'],
      default: 'draft',
    },
    total: {
      type: Number,
      required: [true, 'Total is required'],
      min: [0, 'Total must be greater than or equal to 0'],
    },
    notes: {
      type: String,
      trim: true,
    },
    expectedDeliveryDate: {
      type: Date,
    },
  },
  {
    timestamps: true,
  }
);

// Create indexes for faster queries
purchaseOrderSchema.index({ supplier: 1, createdAt: -1 });
purchaseOrderSchema.index({ status: 1, createdAt: -1 });

// Pre-save middleware to calculate totals
purchaseOrderSchema.pre('save', function(next) {
  if (this.isModified('items')) {
    this.total = this.items.reduce((sum, item) => sum + item.total, 0);
  }
  next();
});

export const PurchaseOrder = mongoose.model<IPurchaseOrder>('PurchaseOrder', purchaseOrderSchema); 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\models\purchaseOrderAccessToken.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';

export interface IPurchaseOrderAccessToken extends Document {
  purchaseOrder: mongoose.Types.ObjectId;
  user: mongoose.Types.ObjectId;
  token: string;
  expiresAt: Date;
  operation: 'receive' | 'cancel' | 'approve';
  items: {
    product: mongoose.Types.ObjectId;
    quantity: number;
  }[];
  status: 'active' | 'completed' | 'expired' | 'cancelled';
  createdAt: Date;
  updatedAt: Date;
}

const purchaseOrderAccessTokenSchema = new Schema({
  purchaseOrder: {
    type: Schema.Types.ObjectId,
    ref: 'PurchaseOrder',
    required: true
  },
  user: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  token: {
    type: String,
    required: true,
    unique: true
  },
  expiresAt: {
    type: Date,
    required: true
  },
  operation: {
    type: String,
    enum: ['receive', 'cancel', 'approve'],
    required: true
  },
  items: [{
    product: {
      type: Schema.Types.ObjectId,
      ref: 'InventoryItem',
      required: true
    },
    quantity: {
      type: Number,
      required: true,
      min: [1, 'Quantity must be greater than 0']
    }
  }],
  status: {
    type: String,
    enum: ['active', 'completed', 'expired', 'cancelled'],
    default: 'active'
  }
}, {
  timestamps: true
});

// Create indexes for efficient querying
purchaseOrderAccessTokenSchema.index({ purchaseOrder: 1, status: 1 });
purchaseOrderAccessTokenSchema.index({ user: 1 });
purchaseOrderAccessTokenSchema.index({ token: 1 }, { unique: true });
purchaseOrderAccessTokenSchema.index({ expiresAt: 1 });

// Generate unique token
purchaseOrderAccessTokenSchema.pre('save', function(next) {
  if (!this.token) {
    this.token = `${this.purchaseOrder}-${this.user}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  next();
});

// Check for existing active tokens
purchaseOrderAccessTokenSchema.pre('save', async function(next) {
  if (this.isNew && this.status === 'active') {
    const existingToken = await this.constructor.findOne({
      purchaseOrder: this.purchaseOrder,
      status: 'active',
      _id: { $ne: this._id }
    });

    if (existingToken) {
      throw new Error('Another user is currently accessing this purchase order');
    }
  }
  next();
});

// Auto-expire tokens
purchaseOrderAccessTokenSchema.methods.checkExpiration = async function() {
  if (this.status === 'active' && this.expiresAt < new Date()) {
    this.status = 'expired';
    await this.save();
  }
};

export const PurchaseOrderAccessToken = mongoose.model<IPurchaseOrderAccessToken>('PurchaseOrderAccessToken', purchaseOrderAccessTokenSchema); 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\models\stockAccessToken.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';

export interface IStockAccessToken extends Document {
  inventoryItem: mongoose.Types.ObjectId;
  user: mongoose.Types.ObjectId;
  token: string;
  expiresAt: Date;
  operation: 'sale' | 'transfer' | 'adjustment';
  quantity: number;
  status: 'active' | 'completed' | 'expired' | 'cancelled';
  details?: {
    destination?: mongoose.Types.ObjectId;
    reason?: string;
  };
  createdAt: Date;
  updatedAt: Date;
}

const stockAccessTokenSchema = new Schema({
  inventoryItem: {
    type: Schema.Types.ObjectId,
    ref: 'InventoryItem',
    required: true
  },
  user: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  token: {
    type: String,
    required: true,
    unique: true
  },
  expiresAt: {
    type: Date,
    required: true
  },
  operation: {
    type: String,
    enum: ['sale', 'transfer', 'adjustment'],
    required: true
  },
  quantity: {
    type: Number,
    required: true,
    min: [1, 'Quantity must be greater than 0'],
    validate: {
      validator: Number.isInteger,
      message: 'Quantity must be a whole number'
    }
  },
  details: {
    destination: {
      type: Schema.Types.ObjectId,
      ref: 'Location'
    },
    reason: String
  },
  status: {
    type: String,
    enum: ['active', 'completed', 'expired', 'cancelled'],
    default: 'active'
  }
}, {
  timestamps: true
});

// Create indexes for efficient querying
stockAccessTokenSchema.index({ inventoryItem: 1, status: 1 });
stockAccessTokenSchema.index({ user: 1 });
stockAccessTokenSchema.index({ token: 1 }, { unique: true });
stockAccessTokenSchema.index({ expiresAt: 1 });

// Generate unique token
stockAccessTokenSchema.pre('save', function(next) {
  if (!this.token) {
    this.token = `${this.inventoryItem}-${this.user}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  next();
});

// Check for existing active tokens
stockAccessTokenSchema.pre('save', async function(next) {
  if (this.isNew && this.status === 'active') {
    const existingToken = await this.constructor.findOne({
      inventoryItem: this.inventoryItem,
      status: 'active',
      _id: { $ne: this._id }
    });

    if (existingToken) {
      throw new Error('Another user is currently accessing this inventory item');
    }
  }
  next();
});

// Auto-expire tokens
stockAccessTokenSchema.methods.checkExpiration = async function() {
  if (this.status === 'active' && this.expiresAt < new Date()) {
    this.status = 'expired';
    await this.save();
  }
};

export const StockAccessToken = mongoose.model<IStockAccessToken>('StockAccessToken', stockAccessTokenSchema); 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\models\stockCategory.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';

export interface IStockCategory extends Document {
  name: string;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
}

const stockCategorySchema = new Schema<IStockCategory>(
  {
    name: {
      type: String,
      required: [true, 'Category name is required'],
      unique: true,
      trim: true,
    },
    description: {
      type: String,
      trim: true,
    },
  },
  {
    timestamps: true,
  }
);

// Create index for faster queries
stockCategorySchema.index({ name: 1 });

export const StockCategory = mongoose.model<IStockCategory>('StockCategory', stockCategorySchema); 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\models\stockMovement.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';
import { User } from '../../auth/models/user.model';

export interface IStockMovement extends Document {
  inventoryItem: mongoose.Types.ObjectId;
  quantity: number;
  type: 'in' | 'out' | 'transfer';
  source?: mongoose.Types.ObjectId;
  destination?: mongoose.Types.ObjectId;
  timestamp: Date;
  user: mongoose.Types.ObjectId;
  notes?: string;
  reference: string;
  status: 'pending' | 'completed' | 'cancelled' | 'reversed';
  reason?: string;
  createdAt: Date;
  updatedAt: Date;
}

const stockMovementSchema = new Schema({
  inventoryItem: {
    type: Schema.Types.ObjectId,
    ref: 'InventoryItem',
    required: true
  },
  quantity: {
    type: Number,
    required: true,
    min: [1, 'Quantity must be greater than 0'],
    validate: {
      validator: Number.isInteger,
      message: 'Quantity must be a whole number'
    }
  },
  type: {
    type: String,
    enum: ['in', 'out', 'transfer'],
    required: true
  },
  source: {
    type: Schema.Types.ObjectId,
    ref: 'Location',
    required: function() {
      return this.type === 'transfer';
    }
  },
  destination: {
    type: Schema.Types.ObjectId,
    ref: 'Location',
    required: function() {
      return this.type === 'transfer';
    }
  },
  timestamp: {
    type: Date,
    default: Date.now,
    validate: {
      validator: function(value: Date) {
        return value <= new Date();
      },
      message: 'Timestamp cannot be in the future'
    }
  },
  user: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  notes: String,
  reference: {
    type: String,
    unique: true
  },
  status: {
    type: String,
    enum: ['pending', 'completed', 'cancelled', 'reversed'],
    default: 'pending'
  },
  reason: {
    type: String,
    required: function() {
      return ['cancelled', 'reversed'].includes(this.status);
    }
  }
}, {
  timestamps: true
});

// Generate unique reference number
stockMovementSchema.pre('save', async function(next) {
  if (!this.reference) {
    const date = new Date();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const year = date.getFullYear().toString().slice(-2);
    const count = await mongoose.model('StockMovement').countDocuments({
      createdAt: {
        $gte: new Date(date.getFullYear(), date.getMonth(), 1),
        $lt: new Date(date.getFullYear(), date.getMonth() + 1, 1)
      }
    });
    this.reference = `SM${year}${month}${(count + 1).toString().padStart(4, '0')}`;
  }
  next();
});

// Check stock availability for outgoing movements
stockMovementSchema.pre('save', async function(next) {
  if (this.type === 'out' && this.status === 'completed') {
    const inventoryItem = await mongoose.model('InventoryItem').findById(this.inventoryItem);
    if (!inventoryItem || inventoryItem.quantity < this.quantity) {
      throw new Error('Insufficient stock available');
    }
  }
  next();
});

// Update inventory item quantity
stockMovementSchema.post('save', async function() {
  if (this.status === 'completed') {
    const inventoryItem = await mongoose.model('InventoryItem').findById(this.inventoryItem);
    if (inventoryItem) {
      const quantityChange = this.type === 'in' ? this.quantity : -this.quantity;
      inventoryItem.quantity += quantityChange;
      await inventoryItem.save();
    }
  }
});

// Prevent deletion of completed movements
stockMovementSchema.pre('remove', function(next) {
  if (this.status === 'completed') {
    throw new Error('Cannot delete completed stock movements');
  }
  next();
});

// Create indexes for efficient querying
stockMovementSchema.index({ inventoryItem: 1 });
stockMovementSchema.index({ user: 1 });
stockMovementSchema.index({ type: 1 });
stockMovementSchema.index({ status: 1 });
stockMovementSchema.index({ reference: 1 });
stockMovementSchema.index({ timestamp: 1 });

export const StockMovement = mongoose.model<IStockMovement>('StockMovement', stockMovementSchema); 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\models\supplier.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';

export interface ISupplier extends Document {
  name: string;
  contact: {
    name: string;
    position?: string;
  };
  address: {
    street: string;
    city: string;
    state: string;
    country: string;
    postalCode: string;
  };
  taxId: string;
  email: string;
  phone: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

const supplierSchema = new Schema<ISupplier>(
  {
    name: {
      type: String,
      required: [true, 'Supplier name is required'],
      trim: true,
    },
    contact: {
      name: {
        type: String,
        required: [true, 'Contact name is required'],
        trim: true,
      },
      position: {
        type: String,
        trim: true,
      },
    },
    address: {
      street: {
        type: String,
        required: [true, 'Street address is required'],
        trim: true,
      },
      city: {
        type: String,
        required: [true, 'City is required'],
        trim: true,
      },
      state: {
        type: String,
        required: [true, 'State is required'],
        trim: true,
      },
      country: {
        type: String,
        required: [true, 'Country is required'],
        trim: true,
      },
      postalCode: {
        type: String,
        required: [true, 'Postal code is required'],
        trim: true,
      },
    },
    taxId: {
      type: String,
      required: [true, 'Tax ID is required'],
      unique: true,
      trim: true,
    },
    email: {
      type: String,
      required: [true, 'Email is required'],
      unique: true,
      lowercase: true,
      trim: true,
    },
    phone: {
      type: String,
      required: [true, 'Phone number is required'],
      trim: true,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
  }
);

// Create indexes for faster queries
supplierSchema.index({ name: 1 });
supplierSchema.index({ email: 1 });
supplierSchema.index({ taxId: 1 });

export const Supplier = mongoose.model<ISupplier>('Supplier', supplierSchema); 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\routes\stock.routes.ts =====
import { Router } from 'express';
import { protect, restrictTo } from '../../shared/middleware/auth.middleware';
import * as stockCategoryController from '../controllers/stockCategory.controller';
import * as supplierController from '../controllers/supplier.controller';
import * as stockMovementController from '../controllers/stockMovement.controller';
import * as purchaseOrderController from '../controllers/purchaseOrder.controller';
import * as inventoryController from '../controllers/inventory.controller';
import { validateRequest } from '../../../middleware/validateRequest';
import { stockMovementSchema } from '../validators/stockMovement.validator';
import { purchaseOrderSchema } from '../validators/purchaseOrder.validator';
import { inventoryItemSchema } from '../validators/inventoryItem.validator';
import { supplierSchema } from '../validators/supplier.validator';
import { stockCategorySchema } from '../validators/stockCategory.validator';
import { stockAccessTokenSchema } from '../schemas/stockAccessToken.schema';
import {
  requestAccessToken,
  releaseAccessToken,
  cancelAccessToken,
  getActiveAccessToken
} from '../controllers/stockAccessToken.controller';
import { purchaseOrderAccessTokenSchema } from '../schemas/purchaseOrderAccessToken.schema';
import {
  requestAccessToken as requestPurchaseOrderAccessToken,
  releaseAccessToken as releasePurchaseOrderAccessToken,
  cancelAccessToken as cancelPurchaseOrderAccessToken,
  getActiveAccessToken as getActivePurchaseOrderAccessToken
} from '../controllers/purchaseOrderAccessToken.controller';

const router = Router();

// Protect all routes
router.use(protect);

// Stock Category routes
router
  .route('/categories')
  .get(stockCategoryController.getAllCategories)
  .post(
    restrictTo('admin', 'stock_manager'),
    validateRequest(stockCategorySchema),
    stockCategoryController.createCategory
  );

router
  .route('/categories/:id')
  .get(stockCategoryController.getCategory)
  .patch(
    restrictTo('admin', 'stock_manager'),
    validateRequest(stockCategorySchema),
    stockCategoryController.updateCategory
  )
  .delete(
    restrictTo('admin', 'stock_manager'),
    stockCategoryController.deleteCategory
  );

// Supplier routes
router
  .route('/suppliers')
  .get(supplierController.getAllSuppliers)
  .post(
    restrictTo('admin', 'stock_manager'),
    validateRequest(supplierSchema),
    supplierController.createSupplier
  );

router
  .route('/suppliers/:id')
  .get(supplierController.getSupplier)
  .patch(
    restrictTo('admin', 'stock_manager'),
    validateRequest(supplierSchema),
    supplierController.updateSupplier
  )
  .delete(
    restrictTo('admin', 'stock_manager'),
    supplierController.deleteSupplier
  );

router
  .route('/suppliers/:id/toggle-status')
  .patch(
    restrictTo('admin', 'stock_manager'),
    supplierController.toggleSupplierStatus
  );

// Stock Movement routes
router
  .route('/movements')
  .get(stockMovementController.getAllMovements)
  .post(
    restrictTo('admin', 'stock_manager'),
    validateRequest(stockMovementSchema),
    stockMovementController.createMovement
  );

router
  .route('/movements/:id')
  .get(stockMovementController.getMovement)
  .patch(
    restrictTo('admin', 'stock_manager'),
    validateRequest(stockMovementSchema),
    stockMovementController.updateMovement
  )
  .delete(
    restrictTo('admin'),
    stockMovementController.deleteMovement
  );

router
  .route('/movements/:id/cancel')
  .post(
    restrictTo('admin', 'stock_manager'),
    stockMovementController.cancelMovement
  );

// Purchase Order routes
router
  .route('/purchase-orders')
  .get(purchaseOrderController.getAllPurchaseOrders)
  .post(
    restrictTo('admin', 'stock_manager'),
    validateRequest(purchaseOrderSchema),
    purchaseOrderController.createPurchaseOrder
  );

router
  .route('/purchase-orders/:id')
  .get(purchaseOrderController.getPurchaseOrder)
  .patch(
    restrictTo('admin', 'stock_manager'),
    validateRequest(purchaseOrderSchema),
    purchaseOrderController.updatePurchaseOrder
  )
  .delete(
    restrictTo('admin', 'stock_manager'),
    purchaseOrderController.deletePurchaseOrder
  );

router
  .route('/purchase-orders/:id/status')
  .patch(
    restrictTo('admin', 'stock_manager'),
    purchaseOrderController.updatePurchaseOrderStatus
  );

// Inventory routes
router
  .route('/inventory')
  .get(inventoryController.getAllInventoryItems)
  .post(
    restrictTo('admin', 'stock_manager'),
    validateRequest(inventoryItemSchema),
    inventoryController.createInventoryItem
  );

router
  .route('/inventory/:id')
  .get(inventoryController.getInventoryItem)
  .patch(
    restrictTo('admin', 'stock_manager'),
    validateRequest(inventoryItemSchema),
    inventoryController.updateInventoryItem
  )
  .delete(
    restrictTo('admin', 'stock_manager'),
    inventoryController.deleteInventoryItem
  );

// Stock access token routes
router.post(
  '/access-token',
  protect,
  restrictTo('admin', 'stock_manager', 'sales_clerk'),
  validateRequest(stockAccessTokenSchema),
  requestAccessToken
);

router.post(
  '/access-token/:token/release',
  protect,
  releaseAccessToken
);

router.post(
  '/access-token/:token/cancel',
  protect,
  cancelAccessToken
);

router.get(
  '/access-token/:inventoryItem',
  protect,
  getActiveAccessToken
);

// Purchase order access token routes
router.post(
  '/purchase-orders/access-token',
  protect,
  validateRequest(purchaseOrderAccessTokenSchema),
  requestPurchaseOrderAccessToken
);

router.post(
  '/purchase-orders/access-token/:token/release',
  protect,
  releasePurchaseOrderAccessToken
);

router.post(
  '/purchase-orders/access-token/:token/cancel',
  protect,
  cancelPurchaseOrderAccessToken
);

router.get(
  '/purchase-orders/access-token/:purchaseOrder',
  protect,
  getActivePurchaseOrderAccessToken
);

export default router; 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\schemas\purchaseOrderAccessToken.schema.ts =====
import { z } from 'zod';

export const purchaseOrderAccessTokenSchema = z.object({
  purchaseOrder: z.string().min(1, 'Purchase order ID is required'),
  operation: z.enum(['receive', 'cancel', 'approve']),
  items: z.array(z.object({
    product: z.string().min(1, 'Product ID is required'),
    quantity: z.number().positive('Quantity must be positive')
  })).optional()
});

export type PurchaseOrderAccessTokenRequest = z.infer<typeof purchaseOrderAccessTokenSchema>; 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\schemas\stockAccessToken.schema.ts =====
import { z } from 'zod';

export const stockAccessTokenSchema = z.object({
  inventoryItem: z.string().min(1, 'Inventory item ID is required'),
  operation: z.enum(['sale', 'transfer', 'adjustment']),
  quantity: z.number().int().positive('Quantity must be a positive integer'),
  details: z.object({
    destination: z.string().optional(),
    reason: z.string().optional()
  }).refine((data) => {
    // Ensure destination is provided for transfer operations
    if (data.destination === undefined && data.reason === undefined) {
      return true; // For sale operations
    }
    return data.destination !== undefined || data.reason !== undefined;
  }, {
    message: 'Either destination (for transfer) or reason (for adjustment) must be provided'
  })
});

export type StockAccessTokenRequest = z.infer<typeof stockAccessTokenSchema>; 

===== C:\Users\Badr Admin\Desktop\src\modules\stock\schemas\stockMovement.schema.ts =====
import { z } from 'zod';

export const stockMovementSchema = z.object({
  inventoryItem: z.string().min(1, 'Inventory item ID is required'),
  quantity: z.number().int().positive('Quantity must be a positive integer'),
  type: z.enum(['in', 'out', 'transfer']),
  source: z.string().optional(),
  destination: z.string().optional(),
  notes: z.string().optional(),
  timestamp: z.string().optional(),
  accessToken: z.string().optional()
}).refine((data) => {
  // For transfers, source and destination are required
  if (data.type === 'transfer') {
    return !!data.source && !!data.destination;
  }
  return true;
}, {
  message: 'Source and destination are required for transfer movements',
  path: ['source']
}).refine((data) => {
  // For outgoing movements, access token is required
  if (data.type === 'out') {
    return !!data.accessToken;
  }
  return true;
}, {
  message: 'Access token is required for outgoing movements',
  path: ['accessToken']
});

export type StockMovementRequest = z.infer<typeof stockMovementSchema>; 

===== C:\Users\Badr Admin\Desktop\src\routes\auth.routes.ts =====
import { Router } from 'express';
import { authController } from '../controllers/auth.controller';
import { authMiddleware } from '../middleware/auth.middleware';
import { validateRequest } from '../middleware/validation.middleware';
import { authValidation } from '../validation/auth.validation';

const router = Router();

// Public routes
router.post('/login', validateRequest(authValidation.login), authController.login);
router.post('/forgot-password', validateRequest(authValidation.forgotPassword), authController.forgotPassword);
router.post('/reset-password/:token', validateRequest(authValidation.resetPassword), authController.resetPassword);

// Protected routes
router.use(authMiddleware.protect);

router.post('/logout', authController.logout);
router.patch('/change-password', validateRequest(authValidation.changePassword), authController.changePassword);
router.patch('/profile', validateRequest(authValidation.updateProfile), authController.updateProfile);

export default router; 

===== C:\Users\Badr Admin\Desktop\src\routes\company.routes.ts =====
import { Router } from 'express';
import { companyController } from '../controllers/company.controller';
import { authMiddleware } from '../middleware/auth.middleware';
import { validateRequest } from '../middleware/validation.middleware';
import { companyValidation } from '../validation/company.validation';

const router = Router();

// Protected routes
router.use(authMiddleware.protect);

router.get('/', companyController.getAllCompanies);
router.get('/:id', companyController.getCompany);

// Admin routes
router.use(authMiddleware.restrictTo('admin'));

router.post('/', validateRequest(companyValidation.create), companyController.createCompany);
router.patch('/:id', validateRequest(companyValidation.update), companyController.updateCompany);
router.delete('/:id', companyController.deleteCompany);

export default router; 

===== C:\Users\Badr Admin\Desktop\src\routes\contract.routes.ts =====
import { Router } from 'express';
import { contractController } from '../controllers/contract.controller';
import { authMiddleware } from '../middleware/auth.middleware';
import { validateRequest } from '../middleware/validation.middleware';
import { contractValidation } from '../validation/contract.validation';

const router = Router();

// Protected routes
router.use(authMiddleware.protect);

router.get('/', contractController.getAllContracts);
router.get('/:id', contractController.getContract);
router.post('/', validateRequest(contractValidation.create), contractController.createContract);
router.patch('/:id', validateRequest(contractValidation.update), contractController.updateContract);
router.delete('/:id', contractController.deleteContract);
router.post('/:id/generate', contractController.generateContract);

export default router;

===== C:\Users\Badr Admin\Desktop\src\routes\index.ts =====
import { Router } from 'express';
import authRoutes from './auth.routes';
import userRoutes from './user.routes';
import inventoryRoutes from './inventory.routes';
import contractRoutes from './contract.routes';
import invoiceRoutes from './invoice.routes';
import licenseRoutes from './license.routes';
import stockRoutes from '../modules/stock/routes/stock.routes';
import companyRoutes from './company.routes';
import { authMiddleware } from '../middleware/auth.middleware';

const router = Router();

// Public routes
router.use('/auth', authRoutes);

// Protected routes
router.use('/company', authMiddleware.protect, companyRoutes);
router.use('/user', authMiddleware.protect, userRoutes);
router.use('/inventory', authMiddleware.protect, inventoryRoutes);
router.use('/contracts', authMiddleware.protect, contractRoutes);
router.use('/licenses', authMiddleware.protect, licenseRoutes);
router.use('/stock', authMiddleware.protect, stockRoutes);
router.use('/invoices', authMiddleware.protect, invoiceRoutes);

export default router; 

===== C:\Users\Badr Admin\Desktop\src\routes\inventory.routes.ts =====
import { Router } from 'express';
import { inventoryController } from '../controllers/inventory.controller';
import { authMiddleware } from '../middleware/auth.middleware';
import { validateRequest } from '../middleware/validation.middleware';
import { inventoryValidation } from '../validation/inventory.validation';

const router = Router();

// Protected routes
router.use(authMiddleware.protect);

router.get('/', inventoryController.getAllItems);
router.get('/:id', inventoryController.getItem);

// Admin routes
router.use(authMiddleware.restrictTo('admin'));

router.post('/', validateRequest(inventoryValidation.create), inventoryController.createItem);
router.patch('/:id', validateRequest(inventoryValidation.update), inventoryController.updateItem);
router.delete('/:id', inventoryController.deleteItem);

export default router;

===== C:\Users\Badr Admin\Desktop\src\routes\invoice.routes.ts =====
import { Router } from 'express';
import { invoiceController } from '../controllers/invoice.controller';
import { authMiddleware } from '../middleware/auth.middleware';
import { validateRequest } from '../middleware/validation.middleware';
import { invoiceValidation } from '../validation/invoice.validation';

const router = Router();

// Protected routes
router.use(authMiddleware.protect);

router.get('/', invoiceController.getAllInvoices);
router.get('/:id', invoiceController.getInvoice);
router.post('/', validateRequest(invoiceValidation.create), invoiceController.createInvoice);
router.patch('/:id', validateRequest(invoiceValidation.update), invoiceController.updateInvoice);
router.delete('/:id', invoiceController.deleteInvoice);

export default router; 

===== C:\Users\Badr Admin\Desktop\src\routes\license.routes.ts =====
import { Router } from 'express';
import { licenseController } from '../controllers/license.controller';
import { authMiddleware } from '../middleware/auth.middleware';
import { validateRequest } from '../middleware/validation.middleware';
import { licenseValidation } from '../validation/license.validation';

const router = Router();

// Protected routes
router.use(authMiddleware.protect);

router.get('/', licenseController.getAllLicenses);
router.get('/:id', licenseController.getLicense);

// Admin routes
router.use(authMiddleware.restrictTo('admin'));

router.post('/', validateRequest(licenseValidation.create), licenseController.createLicense);
router.patch('/:id', validateRequest(licenseValidation.update), licenseController.updateLicense);
router.delete('/:id', licenseController.deleteLicense);

export default router; 

===== C:\Users\Badr Admin\Desktop\src\routes\proforma.routes.ts =====
import express from 'express';
import {
  getAllProformas,
  getProformaById,
  createProforma,
  updateProforma,
  deleteProforma,
  finalizeProforma,
  generatePDF
} from '../controllers/proforma.controller';
import { protect } from '../middleware/auth';

const router = express.Router();

router
  .route('/')
  .get(protect, getAllProformas)
  .post(protect, createProforma);

router
  .route('/:id')
  .get(protect, getProformaById)
  .patch(protect, updateProforma)
  .delete(protect, deleteProforma);

router
  .route('/:id/finalize')
  .post(protect, finalizeProforma);

router
  .route('/:id/pdf')
  .get(protect, generatePDF);

export default router; 

===== C:\Users\Badr Admin\Desktop\src\routes\user.routes.ts =====
import { Router } from 'express';
import { userController } from '../controllers/user.controller';
import { authMiddleware } from '../middleware/auth.middleware';
import { validateRequest } from '../middleware/validation.middleware';
import { userValidation } from '../validation/user.validation';

const router = Router();

// Public routes
router.post('/register', validateRequest(userValidation.register), userController.register);
router.post('/login', validateRequest(userValidation.login), userController.login);
router.post('/forgot-password', validateRequest(userValidation.forgotPassword), userController.forgotPassword);
router.post('/reset-password/:token', validateRequest(userValidation.resetPassword), userController.resetPassword);

// Protected routes
router.use(authMiddleware.protect);

router.get('/profile', userController.getProfile);
router.patch('/profile', validateRequest(userValidation.updateProfile), userController.updateProfile);
router.patch('/change-password', validateRequest(userValidation.changePassword), userController.changePassword);

// Admin routes
router.use(authMiddleware.restrictTo('admin'));

router.get('/', userController.getAllUsers);
router.get('/:id', userController.getUser);
router.patch('/:id', validateRequest(userValidation.updateUser), userController.updateUser);
router.delete('/:id', userController.deleteUser);

export default router;

===== C:\Users\Badr Admin\Desktop\src\schemas\company.schema.ts =====
import { object, string } from 'yup';

export const companySchema = object({
  name: string().required('Company name is required').trim(),
  address: string().required('Company address is required').trim(),
  phone: string().required('Company phone is required').trim(),
  email: string()
    .required('Company email is required')
    .email('Please enter a valid email address')
    .trim()
    .lowercase(),
  website: string()
    .url('Please enter a valid URL')
    .trim()
    .optional(),
  logo: string().optional(),
  taxId: string().trim().optional(),
}); 

===== C:\Users\Badr Admin\Desktop\src\schemas\user.schema.ts =====
import { Schema } from 'yup';
import * as yup from 'yup';

export const userSchema: Schema = yup.object().shape({
  username: yup
    .string()
    .matches(
      /^(SA|UA|U)\d{5}$/,
      'Username must follow the format: SA00000 (Superadmin), UA00001 (Admin), or U00002 (User)'
    )
    .required('Username is required'),

  password: yup
    .string()
    .min(8, 'Password must be at least 8 characters long')
    .matches(/\d/, 'Password must contain at least one number')
    .matches(/[a-z]/, 'Password must contain at least one lowercase letter')
    .matches(/[A-Z]/, 'Password must contain at least one uppercase letter')
    .matches(/[!@#$%^&*]/, 'Password must contain at least one special character')
    .optional(),

  firstName: yup
    .string()
    .min(2, 'First name must be at least 2 characters')
    .max(50, 'First name must be at most 50 characters')
    .optional(),

  lastName: yup
    .string()
    .min(2, 'Last name must be at least 2 characters')
    .max(50, 'Last name must be at most 50 characters')
    .optional(),

  role: yup
    .string()
    .oneOf(['superadmin', 'admin', 'user'], 'Role must be either superadmin, admin, or user')
    .optional(),

  isAuthorized: yup
    .boolean()
    .default(false)
    .optional(),

  settings: yup
    .object()
    .optional(),

  organization: yup
    .string()
    .matches(/^[0-9a-fA-F]{24}$/, 'Organization must be a valid MongoDB ID')
    .optional()
}); 

===== C:\Users\Badr Admin\Desktop\src\scripts\checkUser.ts =====
 

===== C:\Users\Badr Admin\Desktop\src\scripts\createSuperAdmin.ts =====
import mongoose from 'mongoose';
import { User } from '../models/user.model';
import { config } from '../config';

const createSuperAdmin = async () => {
  try {
    await mongoose.connect(config.database.uri);
    console.log('Connected to MongoDB');

    const superAdmin = await User.findOne({ email: 'superadmin@stockhr.com' });
    
    if (!superAdmin) {
      console.log('Creating superadmin user...');
      await User.create({
        email: 'superadmin@stockhr.com',
        password: 'SuperAdmin123!',
        firstName: 'Super',
        lastName: 'Admin',
        role: 'SUPERADMIN',
        permissions: ['ALL'],
        active: true
      });
      console.log('Superadmin user created successfully');
    } else {
      console.log('Superadmin user already exists');
    }

    await mongoose.disconnect();
    console.log('Disconnected from MongoDB');
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
};

createSuperAdmin(); 

===== C:\Users\Badr Admin\Desktop\src\scripts\initializeDb.ts =====
import mongoose from 'mongoose';
import User from '../models/user.model';
import dotenv from 'dotenv';

dotenv.config();

const initializeDb = async () => {
  try {
    const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/stockhr';
    console.log('Connecting to MongoDB...');
    await mongoose.connect(MONGODB_URI);
    console.log('Connected to MongoDB');

    // Check if we have any users
    const usersCount = await User.countDocuments();
    
    if (usersCount === 0) {
      console.log('No users found. Creating superadmin...');

      // Create superadmin user
      const superAdmin = await User.create({
        email: 'admin@stockhr.com',
        password: 'admin123',
        firstName: 'Super',
        lastName: 'Admin',
        role: 'superadmin',
        active: true,
        preferences: {
          language: 'en',
          theme: 'light',
          notifications: true,
          twoFactorEnabled: false
        }
      });

      console.log('Superadmin created successfully');
      console.log('Email: admin@stockhr.com');
      console.log('Password: admin123');
    } else {
      console.log(`Database already has ${usersCount} users. No initialization needed.`);
    }

    // Disconnect from MongoDB
    await mongoose.disconnect();
    console.log('Disconnected from MongoDB');
    process.exit(0);
  } catch (error) {
    console.error('Database initialization failed:', error);
    process.exit(1);
  }
};

// Run the initialization
initializeDb(); 

===== C:\Users\Badr Admin\Desktop\src\scripts\seed.ts =====
import mongoose from 'mongoose';
import { config } from '../config';
import { User } from '../models/user.model';
import bcrypt from 'bcryptjs';

const createSuperAdmin = async () => {
  try {
    await mongoose.connect(config.database.uri);
    console.log('Connected to MongoDB');

    const superadminEmail = 'superadmin@stockhr.com';
    const superadminPassword = 'SuperAdmin123!';

    // Check if superadmin exists
    const existingSuperadmin = await User.findOne({ email: superadminEmail }).select('+active +password');
    
    if (existingSuperadmin) {
      console.log('Updating existing superadmin user...');
      // Update existing superadmin
      const hashedPassword = await bcrypt.hash(superadminPassword, 12);
      existingSuperadmin.password = hashedPassword;
      existingSuperadmin.active = true;
      existingSuperadmin.role = 'SUPERADMIN';
      await existingSuperadmin.save({ validateBeforeSave: false });
      console.log('Superadmin user updated successfully');
    } else {
      console.log('Creating new superadmin user...');
      // Create new superadmin
      const hashedPassword = await bcrypt.hash(superadminPassword, 12);
      await User.create({
        email: superadminEmail,
        password: hashedPassword,
        firstName: 'Super',
        lastName: 'Admin',
        role: 'SUPERADMIN',
        active: true,
        permissions: ['ALL'],
        preferences: {
          language: 'en',
          theme: 'light',
          notifications: true,
          twoFactorEnabled: false
        },
        loginAttempts: 0,
        sessions: [],
        mfa: {
          enabled: false,
          backupCodes: []
        },
        auditLog: [],
        settings: {
          emailNotifications: {
            security: true,
            updates: true,
            marketing: false
          },
          accessibility: {
            fontSize: 'medium',
            contrast: 'normal',
            animations: true
          },
          workspace: {
            defaultView: 'grid',
            defaultLanguage: 'en',
            startPage: 'dashboard',
            recentItems: [],
            favorites: [],
            customShortcuts: []
          }
        }
      });
      console.log('Superadmin user created successfully');
    }

    // Verify the user was created/updated correctly
    const verifiedUser = await User.findOne({ email: superadminEmail }).select('+active +password');
    console.log('Verified user:', {
      email: verifiedUser?.email,
      role: verifiedUser?.role,
      active: verifiedUser?.active,
      hasPassword: !!verifiedUser?.password,
      password: verifiedUser?.password ? '[HIDDEN]' : undefined
    });

    await mongoose.disconnect();
    console.log('Disconnected from MongoDB');
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
};

createSuperAdmin(); 

===== C:\Users\Badr Admin\Desktop\src\scripts\testLogin.ts =====
import mongoose from 'mongoose';
import { config } from '../config';
import { User } from '../models/user.model';
import bcrypt from 'bcryptjs';

async function testLogin() {
  try {
    // Connect to MongoDB
    await mongoose.connect(config.database.uri);
    console.log('Connected to MongoDB');

    // Find user
    const user = await User.findOne({ email: 'superadmin@stockhr.com' }).select('+password +active');
    
    if (!user) {
      console.log('User not found');
      return;
    }

    console.log('User found:', {
      email: user.email,
      role: user.role,
      active: user.active,
      hasPassword: !!user.password,
      passwordLength: user.password?.length
    });

    // Test password
    const testPassword = 'SuperAdmin123!';
    const isPasswordValid = await bcrypt.compare(testPassword, user.password);
    
    console.log('Password test:', {
      testPassword,
      isPasswordValid,
      storedPasswordHash: user.password
    });

    // Create a new hash for comparison
    const newHash = await bcrypt.hash(testPassword, 12);
    console.log('New hash test:', {
      newHash,
      storedHash: user.password,
      hashesMatch: newHash === user.password
    });

  } catch (error) {
    console.error('Error:', error);
  } finally {
    await mongoose.disconnect();
    console.log('Disconnected from MongoDB');
  }
}

testLogin(); 

===== C:\Users\Badr Admin\Desktop\src\services\AIService.ts =====
import { Analytics } from '../models/analytics.model';
import { User } from '../models/user.model';
import { CacheService } from './CacheService';

export class AIService {
  private cache: CacheService;

  constructor() {
    this.cache = CacheService.getInstance();
  }

  public async predictPerformance(userId: string) {
    const historicalData = await this.getHistoricalData(userId);
    const prediction = await this.generatePredictions(historicalData);
    await this.cache.set(`predictions:${userId}`, prediction, 3600);
    return prediction;
  }

  private async getHistoricalData(userId: string) {
    const user = await User.findById(userId)
      .select('analytics.kpis.performance')
      .lean();
    
    const analytics = await Analytics.find({
      'metadata.userId': userId,
      timestamp: { $gte: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) }
    }).sort({ timestamp: 1 });

    return { user, analytics };
  }

  private async generatePredictions(data: any) {
    // Implement ML model predictions
    const predictions = {
      performanceScore: this.calculatePerformanceScore(data),
      burnoutRisk: this.assessBurnoutRisk(data),
      recommendations: this.generateRecommendations(data)
    };

    return predictions;
  }

  private calculatePerformanceScore(data: any) {
    // Implement performance scoring algorithm
    return {
      current: 0,
      trend: [],
      prediction: 0
    };
  }
}


===== C:\Users\Badr Admin\Desktop\src\services\AnalyticsEngine.ts =====
import { CacheService } from './CacheService';
import { WebSocketService } from './WebSocketService';

export class AnalyticsEngine {
  private cache: CacheService;
  private ws: WebSocketService;

  constructor() {
    this.cache = CacheService.getInstance();
    this.ws = WebSocketService.getInstance();
  }

  public async processRealTimeData(data: any) {
    const processed = await this.analyzeData(data);
    await this.cache.set(`analytics:${Date.now()}`, processed);
    this.ws.broadcast('analytics-update', processed);
    return processed;
  }

  private async analyzeData(data: any) {
    // Implementation of data analysis algorithms
    return {
      metrics: this.calculateMetrics(data),
      predictions: await this.generatePredictions(data),
      recommendations: this.generateRecommendations(data)
    };
  }
}


===== C:\Users\Badr Admin\Desktop\src\services\AuthService.ts =====
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import { User } from '../models/user.model';
import { config } from '../config';
import { AppError } from '../utils/errorHandler';

export class AuthService {
  static async login(email: string, password: string) {
    const user = await User.findOne({ email });
    if (!user) {
      throw new AppError('Invalid credentials', 'AUTH_001', 401);
    }

    const isValidPassword = await user.comparePassword(password);
    if (!isValidPassword) {
      throw new AppError('Invalid credentials', 'AUTH_002', 401);
    }

    const token = this.generateToken(user);
    const refreshToken = this.generateRefreshToken(user);

    user.lastLogin = new Date();
    await user.save();

    return { user, token, refreshToken };
  }

  private static generateToken(user: any) {
    return jwt.sign(
      { id: user._id, role: user.role },
      config.jwt.secret,
      { expiresIn: config.jwt.expiresIn }
    );
  }

  private static generateRefreshToken(user: any) {
    return jwt.sign(
      { id: user._id, version: user.tokenVersion },
      config.jwt.secret,
      { expiresIn: config.jwt.refreshExpiresIn }
    );
  }
}


===== C:\Users\Badr Admin\Desktop\src\services\CacheService.ts =====
import Redis from 'ioredis';
import { config } from '../config';

export class CacheService {
  private static instance: CacheService;
  private client: Redis;

  private constructor() {
    this.client = new Redis(config.redis.url, {
      retryStrategy: (times) => {
        const delay = Math.min(times * 50, 2000);
        return delay;
      }
    });

    this.client.on('error', (error) => {
      console.error('Redis Error:', error);
    });
  }

  public static getInstance(): CacheService {
    if (!CacheService.instance) {
      CacheService.instance = new CacheService();
    }
    return CacheService.instance;
  }

  async get<T>(key: string): Promise<T | null> {
    const value = await this.client.get(key);
    return value ? JSON.parse(value) : null;
  }

  async set(key: string, value: any, expirySeconds?: number): Promise<void> {
    const stringValue = JSON.stringify(value);
    if (expirySeconds) {
      await this.client.setex(key, expirySeconds, stringValue);
    } else {
      await this.client.set(key, stringValue);
    }
  }

  async delete(key: string): Promise<void> {
    await this.client.del(key);
  }

  async flush(): Promise<void> {
    await this.client.flushall();
  }
}


===== C:\Users\Badr Admin\Desktop\src\services\CoreService.ts =====
import { CacheService } from './CacheService';
import { WebSocketService } from './WebSocketService';
import { AuthService } from './AuthService';

export class CoreService {
  private static instance: CoreService;
  private cache: CacheService;
  private websocket: WebSocketService;
  private auth: AuthService;

  private constructor() {
    this.cache = CacheService.getInstance();
    this.auth = new AuthService();
  }

  public static getInstance(): CoreService {
    if (!CoreService.instance) {
      CoreService.instance = new CoreService();
    }
    return CoreService.instance;
  }

  public initializeWebSocket(server: any) {
    this.websocket = new WebSocketService(server);
  }

  // Core business logic methods
  public async processInventoryUpdate(data: any) {
    // Cache the update
    await this.cache.set(`inventory:${data.id}`, data);
    
    // Broadcast to relevant users
    this.websocket.broadcast('inventory-update', data);
    
    // Track analytics
    await this.trackAnalytics('inventory-update', data);
  }

  public async trackAnalytics(event: string, data: any) {
    const analyticsData = {
      event,
      timestamp: new Date(),
      data
    };

    await this.cache.set(`analytics:${Date.now()}`, analyticsData);
  }
}


===== C:\Users\Badr Admin\Desktop\src\services\EventBus.ts =====
import { EventEmitter } from 'events';
import { WebSocketService } from './WebSocketService';
import { CacheService } from './CacheService';

export class EventBus {
  private static instance: EventBus;
  private emitter: EventEmitter;
  private ws: WebSocketService;
  private cache: CacheService;

  private constructor() {
    this.emitter = new EventEmitter();
    this.ws = WebSocketService.getInstance();
    this.cache = CacheService.getInstance();
    this.setupHandlers();
  }

  private setupHandlers() {
    this.emitter.on('data:update', async (data) => {
      await this.cache.invalidate(data.key);
      this.ws.broadcast('update', data);
    });

    this.emitter.on('system:alert', (alert) => {
      this.ws.broadcast('alert', alert);
    });
  }

  public emit(event: string, data: any) {
    this.emitter.emit(event, data);
  }
}


===== C:\Users\Badr Admin\Desktop\src\services\MonitoringService.ts =====
import { createClient } from 'redis';
import mongoose from 'mongoose';
import { System } from '../models/system.model';

export class MonitoringService {
  private static instance: MonitoringService;

  public async checkSystemHealth(): Promise<Record<string, any>> {
    const health = {
      status: 'healthy',
      timestamp: new Date(),
      services: {
        database: await this.checkDatabaseHealth(),
        cache: await this.checkRedisHealth(),
        disk: await this.checkDiskSpace(),
        memory: await this.checkMemoryUsage()
      },
      metrics: await this.collectMetrics()
    };

    await System.create({ ...health }); // Store health check
    return health;
  }

  private async checkDatabaseHealth() {
    try {
      const status = await mongoose.connection.db.admin().ping();
      return { status: 'up', latency: status.ok };
    } catch (error) {
      return { status: 'down', error: error.message };
    }
  }

  // ... implementation of other health check methods
}


===== C:\Users\Badr Admin\Desktop\src\services\NotificationService.ts =====
import { WebSocketService } from './WebSocketService';
import { User } from '../models/user.model';
import { EmailService } from './EmailService';

export class NotificationService {
  private static instance: NotificationService;
  private ws: WebSocketService;
  private email: EmailService;

  private constructor() {
    this.ws = WebSocketService.getInstance();
    this.email = new EmailService();
  }

  public static getInstance(): NotificationService {
    if (!this.instance) {
      this.instance = new NotificationService();
    }
    return this.instance;
  }

  public async notify(userId: string, notification: any) {
    const user = await User.findById(userId);
    if (!user) return;

    // Real-time notification
    this.ws.sendToUser(userId, 'notification', notification);

    // Email notification if enabled
    if (user.settings?.emailNotifications?.updates) {
      await this.email.sendNotification(user.email, notification);
    }

    // Store notification
    await this.storeNotification(userId, notification);
  }

  public async broadcastToTeam(teamId: string, notification: any) {
    const teamMembers = await User.find({ 'teams.id': teamId });
    
    for (const member of teamMembers) {
      await this.notify(member._id, notification);
    }
  }
}


===== C:\Users\Badr Admin\Desktop\src\services\OptimizationEngine.ts =====
import { CacheService } from './CacheService';
import { Analytics } from '../models/analytics.model';

export class OptimizationEngine {
  private cache: CacheService;

  constructor() {
    this.cache = CacheService.getInstance();
  }

  async optimizeQueries(query: any) {
    const optimized = await this.analyzeAndOptimize(query);
    return optimized;
  }

  async cacheStrategy(key: string) {
    const analytics = await Analytics.findOne({ key });
    return this.determineCachePolicy(analytics);
  }
}


===== C:\Users\Badr Admin\Desktop\src\services\pdf.service.ts =====
import PDFDocument from 'pdfkit';
import { IInvoice } from '../models/invoice.model';
import { IProforma } from '../models/proforma.model';
import { ICompany } from '../models/company.model';
import fs from 'fs';
import path from 'path';

export class PDFService {
  private static async addCompanyHeader(doc: PDFKit.PDFDocument, company: ICompany) {
    // Add company logo if exists
    if (company.logo) {
      doc.image(company.logo, 50, 45, { width: 100 });
    }

    // Add company details
    doc.fontSize(12)
       .text(company.name, 50, 50)
       .fontSize(10)
       .text(company.address, 50, 70)
       .text(`NIF: ${company.nif}`, 50, 85);

    if (company.phone) {
      doc.text(`Tel: ${company.phone}`, 50, 100);
    }
    if (company.email) {
      doc.text(`Email: ${company.email}`, 50, 115);
    }
    if (company.website) {
      doc.text(`Web: ${company.website}`, 50, 130);
    }
  }

  private static async addClientDetails(doc: PDFKit.PDFDocument, client: { name: string; address: string; nif?: string }) {
    doc.fontSize(12)
       .text('Client:', 300, 50)
       .fontSize(10)
       .text(client.name, 300, 70)
       .text(client.address, 300, 85);

    if (client.nif) {
      doc.text(`NIF: ${client.nif}`, 300, 100);
    }
  }

  private static async addInvoiceDetails(doc: PDFKit.PDFDocument, invoice: IInvoice | IProforma) {
    const isProforma = 'type' in invoice && invoice.type === 'proforma';
    const title = isProforma ? 'Facture Proforma' : 'Facture DÃ©finitive';
    const date = 'date' in invoice ? invoice.date : invoice.createdAt;
    const dueDate = 'dueDate' in invoice ? invoice.dueDate : new Date(date.getTime() + 30 * 24 * 60 * 60 * 1000); // Default 30 days

    doc.fontSize(20)
       .text(title, 50, 180)
       .fontSize(12)
       .text(`NumÃ©ro: ${invoice.invoiceNumber}`, 50, 210)
       .text(`Date: ${date.toLocaleDateString('fr-FR')}`, 50, 225)
       .text(`Ã‰chÃ©ance: ${dueDate.toLocaleDateString('fr-FR')}`, 50, 240)
       .text(`Conditions de paiement: ${invoice.paymentTerms}`, 50, 255);
  }

  private static async addItemsTable(doc: PDFKit.PDFDocument, items: Array<{ description: string; quantity: number; unitPrice: number; total: number; barcode?: string }>) {
    const tableTop = 300;
    const itemX = 50;
    const quantityX = 250;
    const priceX = 350;
    const totalX = 450;

    // Table headers
    doc.fontSize(10)
       .text('Description', itemX, tableTop)
       .text('QuantitÃ©', quantityX, tableTop)
       .text('Prix unitaire', priceX, tableTop)
       .text('Total', totalX, tableTop);

    // Table rows
    let y = tableTop + 20;
    items.forEach(item => {
      doc.text(item.description, itemX, y)
         .text(item.quantity.toString(), quantityX, y)
         .text(item.unitPrice.toFixed(2), priceX, y)
         .text(item.total.toFixed(2), totalX, y);

      if (item.barcode) {
        // Add barcode if available
        // Note: You'll need to implement barcode generation
      }

      y += 20;
    });
  }

  private static async addTotals(doc: PDFKit.PDFDocument, invoice: IInvoice | IProforma) {
    const totalsY = 500;
    const labelX = 350;
    const valueX = 450;

    doc.fontSize(10)
       .text('Total HT:', labelX, totalsY)
       .text(invoice.subtotal.toFixed(2), valueX, totalsY)
       .text(`TVA (${invoice.vatRate}%):`, labelX, totalsY + 20)
       .text(invoice.vatAmount.toFixed(2), valueX, totalsY + 20)
       .fontSize(12)
       .text('Total TTC:', labelX, totalsY + 40)
       .text(('totalAmount' in invoice ? invoice.totalAmount : invoice.total).toFixed(2), valueX, totalsY + 40);
  }

  private static async addSignature(doc: PDFKit.PDFDocument, signature?: string) {
    if (signature) {
      doc.image(signature, 50, 600, { width: 150 });
    }
    doc.fontSize(10)
       .text('Signature', 50, 650);
  }

  private static async addQRCode(doc: PDFKit.PDFDocument, qrCode?: string) {
    if (qrCode) {
      doc.image(qrCode, 450, 600, { width: 100 });
    }
  }

  public static async generateInvoicePDF(invoice: IInvoice | IProforma, company: ICompany): Promise<string> {
    return new Promise(async (resolve, reject) => {
      try {
        const doc = new PDFDocument({ size: 'A4', margin: 50 });
        const date = 'date' in invoice ? invoice.date : invoice.createdAt;
        const fileName = `Facture_${invoice.invoiceNumber}_${invoice.client.name}_${date.toISOString().split('T')[0]}.pdf`;
        const filePath = path.join(__dirname, '../../uploads/invoices', fileName);

        // Create directory if it doesn't exist
        const dir = path.dirname(filePath);
        if (!fs.existsSync(dir)) {
          fs.mkdirSync(dir, { recursive: true });
        }

        const stream = fs.createWriteStream(filePath);
        doc.pipe(stream);

        // Add content to PDF
        await this.addCompanyHeader(doc, company);
        await this.addClientDetails(doc, invoice.client);
        await this.addInvoiceDetails(doc, invoice);
        await this.addItemsTable(doc, invoice.items);
        await this.addTotals(doc, invoice);
        await this.addSignature(doc, invoice.signature);
        await this.addQRCode(doc, invoice.qrCode);

        doc.end();

        stream.on('finish', () => {
          resolve(filePath);
        });

        stream.on('error', (error) => {
          reject(error);
        });
      } catch (error) {
        reject(error);
      }
    });
  }
} 

===== C:\Users\Badr Admin\Desktop\src\services\ReportingEngine.ts =====
import PDFDocument from 'pdfkit';
import ExcelJS from 'exceljs';
import { ChartJSNodeCanvas } from 'chartjs-node-canvas';

export class ReportingEngine {
  private chartEngine: ChartJSNodeCanvas;

  constructor() {
    this.chartEngine = new ChartJSNodeCanvas({
      width: 800,
      height: 400,
      backgroundColour: 'white'
    });
  }

  async generateReport(data: any, format: 'pdf' | 'excel') {
    const charts = await this.generateCharts(data);
    return format === 'pdf' 
      ? await this.createPDFReport(data, charts)
      : await this.createExcelReport(data, charts);
  }

  private async generateCharts(data: any) {
    // Chart generation implementation
  }
}


===== C:\Users\Badr Admin\Desktop\src\services\ReportingService.ts =====
import PDFDocument from 'pdfkit';
import ExcelJS from 'exceljs';
import { User } from '../models/user.model';
import { InventoryItem } from '../models/inventory.model';

export class ReportingService {
  private static instance: ReportingService;

  public static getInstance(): ReportingService {
    if (!this.instance) {
      this.instance = new ReportingService();
    }
    return this.instance;
  }

  public async generateInventoryReport(format: 'pdf' | 'excel'): Promise<Buffer> {
    const items = await InventoryItem.find().sort({ category: 1, name: 1 });
    
    if (format === 'pdf') {
      return this.generatePDFReport(items);
    } else {
      return this.generateExcelReport(items);
    }
  }

  private async generatePDFReport(items: any[]): Promise<Buffer> {
    return new Promise((resolve) => {
      const doc = new PDFDocument();
      const chunks: Buffer[] = [];

      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));

      // Add company header
      doc.fontSize(20).text('Stock HR Management', { align: 'center' });
      doc.moveDown();
      doc.fontSize(16).text('Inventory Report', { align: 'center' });
      doc.moveDown();

      // Add date and time
      doc.fontSize(12).text(`Generated: ${new Date().toLocaleString()}`);
      doc.moveDown();

      // Add inventory table
      const tableHeaders = ['Item', 'Category', 'Quantity', 'Price'];
      let yPosition = doc.y;

      // Draw headers
      tableHeaders.forEach((header, i) => {
        doc.text(header, 50 + (i * 130), yPosition);
      });

      // Draw items
      items.forEach((item, index) => {
        yPosition = doc.y + 20;
        doc.text(item.name, 50, yPosition);
        doc.text(item.category, 180, yPosition);
        doc.text(item.quantity.toString(), 310, yPosition);
        doc.text(`$${item.price.toFixed(2)}`, 440, yPosition);
      });

      doc.end();
    });
  }

  private async generateExcelReport(items: any[]): Promise<Buffer> {
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Inventory');

    worksheet.columns = [
      { header: 'Item', key: 'name', width: 30 },
      { header: 'Category', key: 'category', width: 20 },
      { header: 'Quantity', key: 'quantity', width: 15 },
      { header: 'Price', key: 'price', width: 15 },
      { header: 'Total Value', key: 'totalValue', width: 15 },
      { header: 'Last Updated', key: 'updatedAt', width: 20 }
    ];

    items.forEach(item => {
      worksheet.addRow({
        name: item.name,
        category: item.category,
        quantity: item.quantity,
        price: item.price,
        totalValue: item.quantity * item.price,
        updatedAt: item.updatedAt.toLocaleDateString()
      });
    });

    return workbook.xlsx.writeBuffer();
  }
}


===== C:\Users\Badr Admin\Desktop\src\services\WebSocketService.ts =====
import { Server, Socket } from 'socket.io';
import { verifyToken } from '../middleware/auth';
import { IUser } from '../models/user.model';

// Extend the Socket type to include a user property
interface SocketWithUser extends Socket {
  user?: IUser;
  handshake: Socket['handshake'] & {
    auth?: {
      token?: string;
    };
  };
}

export class WebSocketService {
  private static instance: WebSocketService;
  private io: Server;
  private userSockets: Map<string, Set<string>> = new Map();

  private constructor(server: any) {
    this.io = new Server(server, {
      cors: {
        origin: process.env.FRONTEND_URL || 'http://localhost:3000',
        methods: ['GET', 'POST'],
      },
    });

    this.io.use(async (socket: SocketWithUser, next: (err?: Error) => void) => {
      try {
        const token = socket.handshake.auth?.token;
        if (!token) {
          throw new Error('Authentication token is missing');
        }
        const user = await verifyToken(token);
        socket.user = user;
        next();
      } catch (error) {
        next(error instanceof Error ? error : new Error('Unknown error'));
      }
    });

    this.setupEventHandlers();
  }

  public static getInstance(server?: any): WebSocketService {
    if (!WebSocketService.instance) {
      if (!server) {
        throw new Error('Server instance is required for the first initialization');
      }
      WebSocketService.instance = new WebSocketService(server);
    }
    return WebSocketService.instance;
  }

  private setupEventHandlers() {
    this.io.on('connection', (socket: SocketWithUser) => {
      const userId = socket.user?.id;
      if (userId) {
        this.addUserSocket(userId, socket.id);
      }

      socket.on('disconnect', () => {
        if (userId) {
          this.removeUserSocket(userId, socket.id);
        }
      });

      socket.on('join-room', (room: string) => {
        socket.join(room);
      });

      socket.on('get-user-id', () => {
        if (socket.user) {
          const userId = socket.user.id; // Safely access user.id
          console.log(`User ID: ${userId}`);
        } else {
          console.warn('User not authenticated');
        }
      });
    });
  }

  private addUserSocket(userId: string, socketId: string) {
    if (!this.userSockets.has(userId)) {
      this.userSockets.set(userId, new Set());
    }
    this.userSockets.get(userId)?.add(socketId);
  }

  private removeUserSocket(userId: string, socketId: string) {
    this.userSockets.get(userId)?.delete(socketId);
    if (this.userSockets.get(userId)?.size === 0) {
      this.userSockets.delete(userId);
    }
  }

  public broadcast(event: string, data: any) {
    this.io.emit(event, data);
  }

  public sendToUser(userId: string, event: string, data: any) {
    const userSockets = this.userSockets.get(userId);
    if (userSockets) {
      userSockets.forEach((socketId) => {
        this.io.to(socketId).emit(event, data);
      });
    }
  }

  public sendToRoom(room: string, event: string, data: any) {
    this.io.to(room).emit(event, data);
  }
}


===== C:\Users\Badr Admin\Desktop\src\types\authRequest.ts =====
import { Request } from 'express';
import { JwtPayload } from 'jsonwebtoken';

export interface AuthRequest extends Request {
  user?: JwtPayload & {
    id: string;
    email: string;
    role: string;
  };
} 

===== C:\Users\Badr Admin\Desktop\src\types\error.ts =====
export class ApiError extends Error {
  public details?: any; // Add the `details` property

  constructor(
    public message: string,
    public status: number = 500,
    public code?: string
  ) {
    super(message);
    this.name = 'ApiError';
  }

  static badRequest(msg: string) {
    return new ApiError(msg, 400, 'BAD_REQUEST');
  }

  static unauthorized(msg: string = 'Unauthorized') {
    return new ApiError(msg, 401, 'UNAUTHORIZED');
  }

  static forbidden(msg: string = 'Forbidden') {
    return new ApiError(msg, 403, 'FORBIDDEN');
  }

  static notFound(msg: string = 'Not found') {
    return new ApiError(msg, 404, 'NOT_FOUND');
  }
}


===== C:\Users\Badr Admin\Desktop\src\types\express.d.ts =====
import { JwtPayload } from 'jsonwebtoken';

declare global {
  namespace Express {
    interface Request {
      user?: JwtPayload;
    }
  }
} 

===== C:\Users\Badr Admin\Desktop\src\utils\ApiError.ts =====
export class ApiError extends Error {
  statusCode: number;
  isOperational: boolean;

  constructor(statusCode: number, message: string, isOperational = true) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    Error.captureStackTrace(this, this.constructor);
  }
} 

===== C:\Users\Badr Admin\Desktop\src\utils\appError.ts =====
export type ErrorCode = 
  | 'VALIDATION_ERROR'
  | 'AUTHENTICATION_ERROR'
  | 'AUTHORIZATION_ERROR'
  | 'NOT_FOUND'
  | 'CONFLICT'
  | 'INTERNAL_ERROR'
  | 'BAD_REQUEST'
  | 'RATE_LIMIT_EXCEEDED'
  | 'SERVICE_UNAVAILABLE';

export interface ErrorDetails {
  field?: string;
  message: string;
}

export class AppError extends Error {
  public readonly statusCode: number;
  public readonly status: string;
  public readonly isOperational: boolean;
  public readonly details?: ErrorDetails[];
  public readonly code: ErrorCode;
  public readonly timestamp: string;

  constructor(
    message: string,
    statusCode: number,
    details?: ErrorDetails[],
    code?: ErrorCode
  ) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
    this.isOperational = true;
    this.details = details;
    this.code = code || this.getErrorCodeFromStatus(statusCode);
    this.timestamp = new Date().toISOString();

    Error.captureStackTrace(this, this.constructor);
  }

  private getErrorCodeFromStatus(statusCode: number): ErrorCode {
    switch (statusCode) {
      case 400:
        return 'BAD_REQUEST';
      case 401:
        return 'AUTHENTICATION_ERROR';
      case 403:
        return 'AUTHORIZATION_ERROR';
      case 404:
        return 'NOT_FOUND';
      case 409:
        return 'CONFLICT';
      case 429:
        return 'RATE_LIMIT_EXCEEDED';
      case 503:
        return 'SERVICE_UNAVAILABLE';
      default:
        return 'INTERNAL_ERROR';
    }
  }

  public toJSON() {
    return {
      status: this.status,
      code: this.code,
      message: this.message,
      details: this.details,
      timestamp: this.timestamp,
      ...(process.env.NODE_ENV === 'development' && { stack: this.stack }),
    };
  }

  // Helper methods for creating common errors
  static badRequest(message: string, details?: ErrorDetails[]) {
    return new AppError(message, 400, details, 'BAD_REQUEST');
  }

  static unauthorized(message: string = 'Authentication required', details?: ErrorDetails[]) {
    return new AppError(message, 401, details, 'AUTHENTICATION_ERROR');
  }

  static forbidden(message: string = 'Access denied', details?: ErrorDetails[]) {
    return new AppError(message, 403, details, 'AUTHORIZATION_ERROR');
  }

  static notFound(message: string = 'Resource not found', details?: ErrorDetails[]) {
    return new AppError(message, 404, details, 'NOT_FOUND');
  }

  static conflict(message: string, details?: ErrorDetails[]) {
    return new AppError(message, 409, details, 'CONFLICT');
  }

  static validationError(message: string, details?: ErrorDetails[]) {
    return new AppError(message, 400, details, 'VALIDATION_ERROR');
  }

  static rateLimitExceeded(message: string = 'Too many requests', details?: ErrorDetails[]) {
    return new AppError(message, 429, details, 'RATE_LIMIT_EXCEEDED');
  }

  static internal(message: string = 'Internal server error', details?: ErrorDetails[]) {
    return new AppError(message, 500, details, 'INTERNAL_ERROR');
  }

  static serviceUnavailable(message: string = 'Service temporarily unavailable', details?: ErrorDetails[]) {
    return new AppError(message, 503, details, 'SERVICE_UNAVAILABLE');
  }
}

===== C:\Users\Badr Admin\Desktop\src\utils\auth.ts =====
import { Response } from 'express';
import jwt from 'jsonwebtoken';
import { config } from '../config';
import { IUser } from '../models/user.model';

interface JwtPayload {
  id: string;
}

const signToken = (id: string): string => {
  const payload: JwtPayload = { id };
  const options: jwt.SignOptions = {
    expiresIn: config.jwt.expiresIn
  };
  
  return jwt.sign(payload, config.jwt.secret, options);
};

export const createSendToken = (user: IUser, statusCode: number, res: Response): void => {
  const token = signToken(user._id.toString());

  // Remove password from output
  user.password = undefined;

  res.status(statusCode).json({
    status: 'success',
    token,
    data: {
      user: {
        id: user._id,
        username: user.username,
        firstName: user.firstName,
        lastName: user.lastName,
        role: user.role,
        isAuthorized: user.isAuthorized,
        isActive: user.isActive,
        lastLogin: user.lastLogin,
        settings: user.settings
      }
    }
  });
};

export const verifyToken = (token: string): JwtPayload | null => {
  try {
    return jwt.verify(token, config.jwt.secret) as JwtPayload;
  } catch (error) {
    return null;
  }
}; 

===== C:\Users\Badr Admin\Desktop\src\utils\cache.ts =====
import Redis from 'ioredis';
import logger from './logger';

class Cache {
  private client: Redis;
  private static instance: Cache;

  private constructor() {
    this.client = new Redis(process.env.REDIS_URL!);
    
    this.client.on('error', (error) => {
      logger.error('Redis Client Error:', error);
    });
  }

  static getInstance(): Cache {
    if (!Cache.instance) {
      Cache.instance = new Cache();
    }
    return Cache.instance;
  }

  async set(key: string, value: any, expireIn?: number): Promise<void> {
    try {
      const serialized = JSON.stringify(value);
      if (expireIn) {
        await this.client.setex(key, expireIn, serialized);
      } else {
        await this.client.set(key, serialized);
      }
    } catch (error) {
      logger.error('Cache Set Error:', error);
    }
  }

  async get<T>(key: string): Promise<T | null> {
    try {
      const value = await this.client.get(key);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      logger.error('Cache Get Error:', error);
      return null;
    }
  }

  async del(key: string): Promise<void> {
    try {
      await this.client.del(key);
    } catch (error) {
      logger.error('Cache Delete Error:', error);
    }
  }
}

export default Cache.getInstance();


===== C:\Users\Badr Admin\Desktop\src\utils\catchAsync.ts =====
import { Request, Response, NextFunction } from 'express';

type AsyncFunction = (req: Request, res: Response, next: NextFunction) => Promise<any>;

export const catchAsync = (fn: AsyncFunction) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch((err) => next(err));
  };
}; 

===== C:\Users\Badr Admin\Desktop\src\utils\email.ts =====
import nodemailer from 'nodemailer';

export const sendEmail = async (to: string, subject: string, text: string) => {
  const transporter = nodemailer.createTransport({
    host: process.env.SMTP_HOST,
    port: parseInt(process.env.SMTP_PORT || '587', 10),
    auth: {
      user: process.env.SMTP_USER,
      pass: process.env.SMTP_PASS,
    },
  });

  await transporter.sendMail({
    from: process.env.SMTP_USER,
    to,
    subject,
    text,
  });
};


===== C:\Users\Badr Admin\Desktop\src\utils\license.ts =====
import crypto from 'crypto';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export class LicenseManager {
  private static instance: LicenseManager;
  private constructor() {}

  public static getInstance(): LicenseManager {
    if (!LicenseManager.instance) {
      LicenseManager.instance = new LicenseManager();
    }
    return LicenseManager.instance;
  }

  async getHardwareId(): Promise<string> {
    try {
      const { stdout: mbSerial } = await execAsync('wmic baseboard get serialnumber');
      const { stdout: hddSerial } = await execAsync('wmic diskdrive get serialnumber');
      
      const hardwareId = crypto
        .createHash('sha256')
        .update(`${mbSerial}${hddSerial}`)
        .digest('hex');
      
      return hardwareId;
    } catch (error) {
      throw new Error('Failed to get hardware ID');
    }
  }

  generateActivationKey(hardwareId: string): string {
    return crypto
      .createHmac('sha256', process.env.LICENSE_SECRET_KEY || 'default-secret')
      .update(hardwareId)
      .digest('hex');
  }

  async validateLicense(activationKey: string): Promise<boolean> {
    try {
      const hardwareId = await this.getHardwareId();
      const expectedKey = this.generateActivationKey(hardwareId);
      return expectedKey === activationKey;
    } catch (error) {
      return false;
    }
  }
}

export default LicenseManager.getInstance();


===== C:\Users\Badr Admin\Desktop\src\utils\logger.ts =====
import winston from 'winston';
import { format } from 'winston';
import { join } from 'path';
import fs from 'fs';

const { combine, timestamp, printf, colorize } = format;

// Ensure logs directory exists
const logsDir = join(process.cwd(), 'logs');
if (!fs.existsSync(logsDir)) {
  fs.mkdirSync(logsDir);
}

const logFormat = printf((info) => {
  const { level, message, timestamp, ...metadata } = info;
  let msg = `${timestamp} [${level}]: ${message}`;
  if (Object.keys(metadata).length > 0) {
    msg += ` ${JSON.stringify(metadata)}`;
  }
  return msg;
});

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  }));
}

// Handle unhandled rejections and exceptions
process.on('unhandledRejection', (reason: Error) => {
  logger.error('Unhandled Promise Rejection', {
    error: reason.message,
    stack: reason.stack
  });
});

process.on('uncaughtException', (error: Error) => {
  logger.error('Uncaught Exception', {
    error: error.message,
    stack: error.stack
  });
  // Give logger time to write before exiting
  setTimeout(() => {
    process.exit(1);
  }, 1000);
});

export default logger;

// Export a type-safe logging interface
export interface LogMetadata {
  [key: string]: any;
}

export interface TypedLogger {
  error(message: string, metadata?: LogMetadata): void;
  warn(message: string, metadata?: LogMetadata): void;
  info(message: string, metadata?: LogMetadata): void;
  debug(message: string, metadata?: LogMetadata): void;
}

// Create a typed logger instance
export const typedLogger: TypedLogger = {
  error: (message: string, metadata?: LogMetadata) => {
    logger.error(message, metadata);
  },
  warn: (message: string, metadata?: LogMetadata) => {
    logger.warn(message, metadata);
  },
  info: (message: string, metadata?: LogMetadata) => {
    logger.info(message, metadata);
  },
  debug: (message: string, metadata?: LogMetadata) => {
    logger.debug(message, metadata);
  }
};


===== C:\Users\Badr Admin\Desktop\src\utils\passwordValidator.ts =====
import { typedLogger } from './logger';

export interface PasswordValidationResult {
  isValid: boolean;
  error?: string;
  details?: {
    hasMinLength: boolean;
    hasUpperCase: boolean;
    hasLowerCase: boolean;
    hasNumber: boolean;
    hasSpecialChar: boolean;
    hasNoSpaces: boolean;
    isNotCommon: boolean;
    score: number;
  };
}

// Common weak passwords to check against
const COMMON_PASSWORDS = new Set([
  'password', 'password123', '123456', '12345678', 'qwerty',
  'abc123', 'letmein', 'admin', 'welcome', 'monkey', 'dragon',
  'football', 'baseball', 'master', 'login', 'admin123'
]);

// Special characters allowed in passwords
const SPECIAL_CHARS = /[!@#$%^&*(),.?":{}|<>]/;

// Password validation configuration
const PASSWORD_CONFIG = {
  minLength: 8,
  maxLength: 128,
  minScore: 3,
};

// Calculate password strength score (0-5)
const calculatePasswordScore = (password: string): number => {
  let score = 0;

  // Length score
  if (password.length >= PASSWORD_CONFIG.minLength) score++;
  if (password.length >= 12) score++;
  if (password.length >= 16) score++;

  // Character variety score
  const hasUpper = /[A-Z]/.test(password);
  const hasLower = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecial = SPECIAL_CHARS.test(password);

  if (hasUpper && hasLower) score++;
  if (hasNumber) score++;
  if (hasSpecial) score++;

  // Deduct points for patterns
  if (/(.)\1{2,}/.test(password)) score--; // Repeated characters
  if (/^[a-zA-Z]+$/.test(password)) score--; // Only letters
  if (/^[0-9]+$/.test(password)) score--; // Only numbers

  return Math.max(0, Math.min(5, score));
};

export const validatePassword = (
  password: string,
  options: {
    minLength?: number;
    maxLength?: number;
    minScore?: number;
    checkCommonPasswords?: boolean;
  } = {}
): PasswordValidationResult => {
  try {
    const {
      minLength = PASSWORD_CONFIG.minLength,
      maxLength = PASSWORD_CONFIG.maxLength,
      minScore = PASSWORD_CONFIG.minScore,
      checkCommonPasswords = true,
    } = options;

    const details = {
      hasMinLength: password.length >= minLength,
      hasUpperCase: /[A-Z]/.test(password),
      hasLowerCase: /[a-z]/.test(password),
      hasNumber: /[0-9]/.test(password),
      hasSpecialChar: SPECIAL_CHARS.test(password),
      hasNoSpaces: !/\s/.test(password),
      isNotCommon: !checkCommonPasswords || !COMMON_PASSWORDS.has(password.toLowerCase()),
      score: calculatePasswordScore(password),
    };

    // Check for spaces
    if (!details.hasNoSpaces) {
      return {
        isValid: false,
        error: 'Password cannot contain spaces',
        details,
      };
    }

    // Check minimum length
    if (!details.hasMinLength) {
      return {
        isValid: false,
        error: `Password must be at least ${minLength} characters long`,
        details,
      };
    }

    // Check maximum length
    if (password.length > maxLength) {
      return {
        isValid: false,
        error: `Password cannot be longer than ${maxLength} characters`,
        details,
      };
    }

    // Check for uppercase letters
    if (!details.hasUpperCase) {
      return {
        isValid: false,
        error: 'Password must contain at least one uppercase letter',
        details,
      };
    }

    // Check for lowercase letters
    if (!details.hasLowerCase) {
      return {
        isValid: false,
        error: 'Password must contain at least one lowercase letter',
        details,
      };
    }

    // Check for numbers
    if (!details.hasNumber) {
      return {
        isValid: false,
        error: 'Password must contain at least one number',
        details,
      };
    }

    // Check for special characters
    if (!details.hasSpecialChar) {
      return {
        isValid: false,
        error: 'Password must contain at least one special character',
        details,
      };
    }

    // Check for common passwords
    if (!details.isNotCommon) {
      return {
        isValid: false,
        error: 'This password is too common. Please choose a stronger password',
        details,
      };
    }

    // Check password strength score
    if (details.score < minScore) {
      return {
        isValid: false,
        error: 'Password is too weak. Please choose a stronger combination of characters',
        details,
      };
    }

    return {
      isValid: true,
      details,
    };
  } catch (error) {
    typedLogger.error('Password validation error', { error });
    return {
      isValid: false,
      error: 'An error occurred while validating the password',
    };
  }
}; 

===== C:\Users\Badr Admin\Desktop\src\utils\totp.ts =====
import { authenticator } from 'otplib';
import QRCode from 'qrcode';

export const generateTOTP = async (email: string): Promise<{ secret: string; qrCode: string }> => {
  const secret = authenticator.generateSecret();
  const otpauth = authenticator.keyuri(email, 'Stock HR System', secret);
  const qrCode = await QRCode.toDataURL(otpauth);
  
  return { secret, qrCode };
};

export const verifyTOTP = (token: string, secret: string): boolean => {
  return authenticator.verify({ token, secret });
};


===== C:\Users\Badr Admin\Desktop\src\utils\upload.ts =====
import multer from 'multer';
import path from 'path';
import { Request } from 'express';

// Configure multer for file storage
const storage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    cb(null, path.join(__dirname, '../../uploads/logos'));
  },
  filename: (_req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

// File filter to only allow images
const fileFilter = (_req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);
  } else {
    cb(new Error('Not an image! Please upload only images.'));
  }
};

// Create uploads directory if it doesn't exist
const uploadsDir = path.join(__dirname, '../../uploads/logos');
if (!require('fs').existsSync(uploadsDir)) {
  require('fs').mkdirSync(uploadsDir, { recursive: true });
}

// Export configured multer instance
export const upload = multer({
  storage,
  fileFilter: fileFilter as unknown as multer.Options['fileFilter'],
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB limit
  }
}); 

===== C:\Users\Badr Admin\Desktop\src\utils\validateEnv.ts =====
import dotenv from 'dotenv';

dotenv.config();

const requiredEnvVars = ['PORT', 'MONGODB_URI', 'JWT_SECRET'];
const optionalEnvVars = { NODE_ENV: 'development' }; // Default to 'development'

requiredEnvVars.forEach((varName) => {
  if (!process.env[varName]) {
    console.error(`Missing required environment variable: ${varName}`);
    process.exit(1); // Exit if a required variable is missing
  }
});

Object.entries(optionalEnvVars).forEach(([key, defaultValue]) => {
  if (!process.env[key]) {
    console.warn(`Optional environment variable ${key} not set. Using default: ${defaultValue}`);
    process.env[key] = defaultValue;
  }
});


===== C:\Users\Badr Admin\Desktop\src\validation\auth.validation.ts =====
import Joi from 'joi';

export const authValidation = {
  login: Joi.object({
    username: Joi.string()
      .pattern(/^(SA|UA|U)\d{5}$/)
      .required()
      .messages({
        'string.pattern.base': 'Invalid username format',
        'any.required': 'Username is required'
      }),
    password: Joi.string()
      .min(8)
      .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/)
      .required()
      .messages({
        'string.min': 'Password must be at least 8 characters',
        'string.pattern.base': 'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character',
        'any.required': 'Password is required'
      })
  }),

  forgotPassword: Joi.object({
    username: Joi.string()
      .pattern(/^(SA|UA|U)\d{5}$/)
      .required()
      .messages({
        'string.pattern.base': 'Invalid username format',
        'any.required': 'Username is required'
      })
  }),

  resetPassword: Joi.object({
    password: Joi.string()
      .min(8)
      .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/)
      .required()
      .messages({
        'string.min': 'Password must be at least 8 characters',
        'string.pattern.base': 'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character',
        'any.required': 'Password is required'
      })
  }),

  changePassword: Joi.object({
    currentPassword: Joi.string().required(),
    newPassword: Joi.string()
      .min(8)
      .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/)
      .required()
      .messages({
        'string.min': 'Password must be at least 8 characters',
        'string.pattern.base': 'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character',
        'any.required': 'New password is required'
      })
  }),

  updateProfile: Joi.object({
    firstName: Joi.string().optional(),
    lastName: Joi.string().optional(),
    phone: Joi.string().optional(),
    address: Joi.string().optional()
  })
}; 

===== C:\Users\Badr Admin\Desktop\src\validators\auth.validator.ts =====
import { body } from 'express-validator';
import { ROLES } from '../../../shared/config';
import { validatePassword } from '../utils/passwordValidator';

// Name validation regex
const NAME_REGEX = /^[a-zA-Z\s-]+$/;
const NAME_ERROR_MESSAGE = 'Name can only contain letters, spaces, and hyphens';

// Custom password validator using our enhanced validation
const validatePasswordField = (value: string) => {
  const result = validatePassword(value);
  if (!result.isValid) {
    throw new Error(result.error);
  }
  return true;
};

export const loginValidator = [
  body('email')
    .trim()
    .isEmail()
    .withMessage('Please provide a valid email address')
    .normalizeEmail(),
  body('password')
    .notEmpty()
    .withMessage('Password is required'),
];

export const registerValidator = [
  body('email')
    .trim()
    .isEmail()
    .withMessage('Please provide a valid email address')
    .normalizeEmail(),
  body('password')
    .custom(validatePasswordField),
  body('firstName')
    .trim()
    .notEmpty()
    .withMessage('First name is required')
    .isLength({ min: 2, max: 50 })
    .withMessage('First name must be between 2 and 50 characters')
    .matches(NAME_REGEX)
    .withMessage(NAME_ERROR_MESSAGE),
  body('lastName')
    .trim()
    .notEmpty()
    .withMessage('Last name is required')
    .isLength({ min: 2, max: 50 })
    .withMessage('Last name must be between 2 and 50 characters')
    .matches(NAME_REGEX)
    .withMessage(NAME_ERROR_MESSAGE),
  body('role')
    .trim()
    .notEmpty()
    .withMessage('Role is required')
    .isIn(Object.keys(ROLES))
    .withMessage('Invalid role'),
];

export const forgotPasswordValidator = [
  body('email')
    .trim()
    .isEmail()
    .withMessage('Please provide a valid email address')
    .normalizeEmail(),
];

export const resetPasswordValidator = [
  body('password')
    .custom(validatePasswordField),
  body('token')
    .notEmpty()
    .withMessage('Reset token is required')
    .isLength({ min: 32, max: 32 })
    .withMessage('Invalid reset token'),
];

export const changePasswordValidator = [
  body('currentPassword')
    .notEmpty()
    .withMessage('Current password is required'),
  body('newPassword')
    .custom(validatePasswordField),
];

export const updateProfileValidator = [
  body('email')
    .optional()
    .trim()
    .isEmail()
    .withMessage('Please provide a valid email address')
    .normalizeEmail(),
  body('firstName')
    .optional()
    .trim()
    .notEmpty()
    .withMessage('First name cannot be empty')
    .isLength({ min: 2, max: 50 })
    .withMessage('First name must be between 2 and 50 characters')
    .matches(NAME_REGEX)
    .withMessage(NAME_ERROR_MESSAGE),
  body('lastName')
    .optional()
    .trim()
    .notEmpty()
    .withMessage('Last name cannot be empty')
    .isLength({ min: 2, max: 50 })
    .withMessage('Last name must be between 2 and 50 characters')
    .matches(NAME_REGEX)
    .withMessage(NAME_ERROR_MESSAGE),
]; 

===== C:\Users\Badr Admin\Desktop\src\validators\company.validator.ts =====
import Joi from 'joi';

export const companySchema = Joi.object({
  name: Joi.string().required(),
  address: Joi.string().required(),
  nif: Joi.string().required(),
  phone: Joi.string(),
  email: Joi.string().email(),
  website: Joi.string().uri(),
  bankDetails: Joi.object({
    bankName: Joi.string(),
    accountNumber: Joi.string(),
    iban: Joi.string(),
  }),
}); 

===== C:\Users\Badr Admin\Desktop\src\validators\invoice.validator.ts =====
import Joi from 'joi';

export const invoiceSchema = Joi.object({
  type: Joi.string().valid('proforma', 'final').required(),
  client: Joi.object({
    name: Joi.string().required(),
    address: Joi.string().required(),
    nif: Joi.string(),
  }).required(),
  items: Joi.array().items(
    Joi.object({
      description: Joi.string().required(),
      quantity: Joi.number().min(1).required(),
      unitPrice: Joi.number().min(0).required(),
      barcode: Joi.string(),
    })
  ).min(1).required(),
  paymentTerms: Joi.string().required(),
  dueDate: Joi.date().greater('now').required(),
  signature: Joi.string(),
  qrCode: Joi.string(),
}); 

